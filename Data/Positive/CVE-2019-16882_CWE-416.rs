fn resolve_index_to_str(&self, index: usize) -> Option<(&str, usize)> {
        let bytes = self.buffer.get(index..)?;
        let (str_len, str_len_bytes) = decode_var_usize(bytes)?;
        let index_str = index + str_len_bytes;
        let str_bytes = self.buffer.get(index_str..index_str + str_len)?;
        // SAFETY: It is guaranteed by the backend that only valid strings
        //         are stored in this portion of the buffer.
        let string = unsafe { str::from_utf8_unchecked(str_bytes) };
        Some((string, index_str + str_len))
    }

unsafe fn resolve_index_to_str_unchecked(&self, index: usize) -> &str {
        // SAFETY: The function is marked unsafe so that the caller guarantees
        //         that required invariants are checked.
        let slice_len = unsafe { self.buffer.get_unchecked(index..) };
        // SAFETY: The function is marked unsafe so that the caller guarantees
        //         that required invariants are checked.
        let (str_len, str_len_bytes) = unsafe { decode_var_usize_unchecked(slice_len) };
        let start_str = index + str_len_bytes;
        let str_bytes =
            // SAFETY: The function is marked unsafe so that the caller guarantees
            //         that required invariants are checked.
            unsafe { self.buffer.get_unchecked(start_str..start_str + str_len) };
        // SAFETY: It is guaranteed by the backend that only valid strings
        //         are stored in this portion of the buffer.
        unsafe { str::from_utf8_unchecked(str_bytes) }
    }

fn push_string(&mut self, string: &str) -> S {
        let symbol = self.next_symbol();
        let str_len = string.len();
        let str_bytes = string.as_bytes();
        self.encode_var_usize(str_len);
        self.buffer.extend(str_bytes);
        self.len_strings += 1;
        symbol
    }

fn with_capacity(capacity: usize) -> Self {
        /// We encode the `usize` string length into the buffer as well.
        const LEN_USIZE: usize = mem::size_of::<usize>();
        /// According to google the approx. word length is 5.
        const DEFAULT_STR_LEN: usize = 5;
        let bytes_per_string = DEFAULT_STR_LEN * LEN_USIZE;
        Self {
            len_strings: 0,
            buffer: Vec::with_capacity(capacity * bytes_per_string),
            marker: Default::default(),
        }
    }


fn resolve(&self, symbol: Self::Symbol) -> Option<&str> {
        self.resolve_index_to_str(symbol.to_usize())
            .map(|(string, _next_str_index)| string)
    }

pub fn new(backend: &'a BufferBackend<S>) -> Self {
        Self {
            backend,
            yielded: 0,
            current: 0,
        }
    }

fn next(&mut self) -> Option<Self::Item> {
        
        self.backend.resolve_index_to_str(self.current).and_then(
            |(string, next_string_index)| {
                let symbol = S::try_from_usize(self.current)?;
                self.current = next_string_index;
                self.yielded += 1;
                Some((symbol, string))
            },
        )
    }
