fn emit_muldivmod<E: UserDefinedError>(jit: &mut JitCompiler, opc: u8, src: u8, dst: u8, imm: Option<i64>) -> Result<(), EbpfError<E>> {
    let mul = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MUL32_IMM & ebpf::BPF_ALU_OP_MASK);
    let div = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::DIV32_IMM & ebpf::BPF_ALU_OP_MASK);
    let sdiv = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::SDIV32_IMM & ebpf::BPF_ALU_OP_MASK);
    let modrm = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MOD32_IMM & ebpf::BPF_ALU_OP_MASK);
    let size = if (opc & ebpf::BPF_CLS_MASK) == ebpf::BPF_ALU64 { OperandSize::S64 } else { OperandSize::S32 };
    // subtracting offset_in_text_section from TARGET_PC_LOCAL_ANCHOR gives us a
    // unique local anchor
    let sdiv_anchor =  if sdiv { TARGET_PC_LOCAL_ANCHOR - jit.offset_in_text_section } else { 0 };
    if (div || sdiv || modrm) && imm.is_none() {
        // Save pc
        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;
        X86Instruction::test(size, src, src, None).emit(jit)?; // src == 0
        emit_jcc(jit, 0x84, TARGET_PC_DIV_BY_ZERO)?;
    }
    // sdiv overflows with MIN / -1. If we have an immediate and it's not -1, we
    // don't need any checks.
    if sdiv && imm.unwrap_or(-1) == -1 {
        if imm.is_none() {
            // if src != -1, we can skip checking dst
            X86Instruction::cmp_immediate(size, src, -1, None).emit(jit)?;
            emit_jcc(jit, 0x85, sdiv_anchor)?;
        }
        // if dst != MIN, we're not going to overflow
        X86Instruction::load_immediate(size, R11, if size == OperandSize::S64 { i64::MIN } else { i32::MIN as i64 }).emit(jit)?;
        X86Instruction::cmp(size, dst, R11, None).emit(jit)?;
        emit_jcc(jit, 0x85, sdiv_anchor)?;
        // MIN / -1, raise EbpfError::DivideOverflow(pc)
        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;
        emit_jmp(jit, TARGET_PC_DIV_OVERFLOW)?;
    }
    if sdiv {
        set_anchor(jit, sdiv_anchor);
    }
    if dst != RAX {
        X86Instruction::push(RAX, None).emit(jit)?;
    }
    if dst != RDX {
        X86Instruction::push(RDX, None).emit(jit)?;
    }
    if let Some(imm) = imm {
        if should_sanitize_constant(jit, imm) {
            emit_sanitized_load_immediate(jit, OperandSize::S64, R11, imm)?;
        } else {
            X86Instruction::load_immediate(OperandSize::S64, R11, imm).emit(jit)?;
        }
    } else {
        X86Instruction::mov(OperandSize::S64, src, R11).emit(jit)?;
    }
    if dst != RAX {
        X86Instruction::mov(OperandSize::S64, dst, RAX).emit(jit)?;
    }
    if div || modrm {
        // xor %edx,%edx
        emit_alu(jit, size, 0x31, RDX, RDX, 0, None)?;
    } else if sdiv {
        // cdq or cqo depending on operand size
        X86Instruction {
            size,
            opcode: 0x99,
            modrm: false,
            ..X86Instruction::default()
        }.emit(jit)?;
    }
    emit_alu(jit, size, 0xf7, if mul { 4 } else if sdiv { 7 } else { 6 }, R11, 0, None)?;
    if dst != RDX {
        if modrm {
            X86Instruction::mov(OperandSize::S64, RDX, dst).emit(jit)?;
        }
        X86Instruction::pop(RDX).emit(jit)?;
    }
    if dst != RAX {
        if div || sdiv || mul {
            X86Instruction::mov(OperandSize::S64, RAX, dst).emit(jit)?;
        }
        X86Instruction::pop(RAX).emit(jit)?;
    }

    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {
        X86Instruction::sign_extend_i32_to_i64(dst, dst).emit(jit)?;
    }
    Ok(())
}