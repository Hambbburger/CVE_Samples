fn parse_short_str_(&mut self) -> Result<&'de str> {
        let idx = self.iidx + 1;
        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };

        //short strings are very common for IDs
        #[allow(clippy::cast_ptr_alignment)]
        let v: __m256i =
            unsafe { _mm256_loadu_si256(src.get_unchecked(..32).as_ptr() as *const __m256i) };
 
        let bs_bits: u32 = unsafe {
            static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(
                v,
                _mm256_set1_epi8(b'\\' as i8)
            )))
        };
        let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'"' as i8)) };
        let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };
        if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {
            let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;
            
            self.str_offset = idx + quote_dist as usize;

            unsafe {
                let v = self.input.get_unchecked(idx..idx + quote_dist as usize) as *const [u8]
                    as *const str;
                Ok(&*v)
            }
        } else {
            self.parse_str_()
        }
    }


fn parse_str_(&mut self) -> Result<&'de str> {
        use std::slice::from_raw_parts_mut;
        // Add 1 to skip the initial "
        let idx = self.iidx + 1;
        //let mut read: usize = 0;

        let needs_relocation = idx - self.str_offset <= 32;
        // we include the terminal '"' so we know where to end
        // This is safe since we check sub's lenght in the range access above and only
        // create sub sliced form sub to `sub.len()`.
        // if we don't need relocation we can write directly to the input
        // saving us to copy data to the string storage first and then
        // back tot he input.
        // We can't always do that as if we're less then 32 characters
        // behind we'll overwrite important parts of the input.
        let dst: &mut [u8] = if needs_relocation {
            &mut self.strings
        } else {
            let ptr = self.input.as_mut_ptr();
            unsafe {
                from_raw_parts_mut(ptr.add(self.str_offset), self.input.len() - self.str_offset)
            }
        };
        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };
        let mut src_i: usize = 0;
        let mut dst_i: usize = 0;
        loop {
            #[allow(clippy::cast_ptr_alignment)]
            let v: __m256i =
                unsafe { _mm256_loadu_si256(src.as_ptr().add(src_i) as *const __m256i) };
          

            #[allow(clippy::cast_ptr_alignment)]
            unsafe {
                _mm256_storeu_si256(dst.as_mut_ptr().add(dst_i) as *mut __m256i, v)
            };
            // store to dest unconditionally - we can overwrite the bits we don't like
            // later
            let bs_bits: u32 = unsafe {
                static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(
                    v,
                    _mm256_set1_epi8(b'\\' as i8)
                )))
            };
            let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'"' as i8)) };
            let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };
            if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {
                // we encountered quotes first. Move dst to point to quotes and exit
                // find out where the quote is...
                let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;
                ///////////////////////
                // Above, check for overflow in case someone has a crazy string (>=4GB?)
                // But only add the overflow check when the document itself exceeds 4GB
                // Currently unneeded because we refuse to parse docs larger or equal to 4GB.
                ////////////////////////
                // we advance the point, accounting for the fact that we have a NULl termination
                dst_i += quote_dist as usize;
                unsafe {
                    if needs_relocation {
                        self.input
                            .get_unchecked_mut(self.str_offset..self.str_offset + dst_i as usize)
                            .clone_from_slice(&self.strings.get_unchecked(..dst_i));
                    }
                    let v = self
                        .input
                        .get_unchecked(self.str_offset..self.str_offset + dst_i as usize)
                        as *const [u8] as *const str;
                    self.str_offset += dst_i as usize;
                    return Ok(&*v);
                }
                // we compare the pointers since we care if they are 'at the same spot'
                // not if they are the same value
            }
            if (quote_bits.wrapping_sub(1) & bs_bits) != 0 {
                // find out where the backspace is
                let bs_dist: u32 = trailingzeroes(u64::from(bs_bits));
                let escape_char: u8 = unsafe { *src.get_unchecked(src_i + bs_dist as usize + 1) };
                // we encountered backslash first. Handle backslash
                if escape_char == b'u' {
                    // move src/dst up to the start; they will be further adjusted
                    // within the unicode codepoint handling code.
                    src_i += bs_dist as usize;
                    dst_i += bs_dist as usize;
                    let (o, s) = if let Ok(r) =
                        handle_unicode_codepoint(unsafe { src.get_unchecked(src_i..) }, unsafe {
                            dst.get_unchecked_mut(dst_i..)
                        }) {
                        r
                    } else {
                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));
                    };
                    if o == 0 {
                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));
                    };
                    // We moved o steps forword at the destiation and 6 on the source
                    src_i += s;
                    dst_i += o;
                } else {
                    // simple 1:1 conversion. Will eat bs_dist+2 characters in input and
                    // write bs_dist+1 characters to output
                    // note this may reach beyond the part of the buffer we've actually
                    // seen. I think this is ok
                    let escape_result: u8 =
                        unsafe { *ESCAPE_MAP.get_unchecked(escape_char as usize) };
                    if escape_result == 0 {
                        return Err(self.error(ErrorType::InvalidEscape));
                    }
                    unsafe {
                        *dst.get_unchecked_mut(dst_i + bs_dist as usize) = escape_result;
                    }
                    src_i += bs_dist as usize + 2;
                    dst_i += bs_dist as usize + 1;
                }
            } else {
                // they are the same. Since they can't co-occur, it means we encountered
                // neither.
                src_i += 32;
                dst_i += 32;
            }
        }
    }
