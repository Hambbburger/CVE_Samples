    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            ("Start", &start),
            ("End", &end),
            ("Grapheme", &grapheme),
            ("G", &grapheme),
            ("Codepoint", &codepoint),
            ("C", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &'i str,
        parse_options: ParseOptions,
        compile_options: CompileOptions,
    ) -> Result<String, CompileError> {
        let parsed = Self::parse(input, parse_options)?;
        parsed.compile(compile_options)
    }
    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens })
    }
    fn iter_elements(&self) -> Self::IterElem {
        Input { source: self.source, tokens: self.tokens }
    }
    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { source: self.source, tokens }
    }
    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })
    }
pub(crate) fn parse(source: &str) -> Result<Rule<'_>, ParseError> {
    let tokens = super::tokenize::tokenize(source);
    let input = Input::from(source, &tokens)?;

    let (rest, rules) = parse_modified(input)?;
    if rest.is_empty() {
        Ok(rules)
    } else {
        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))
    }
}

pub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    enum ModifierKind {
        Enable,
        Disable,
    }

    try_map2(
        pair(
            many0(alt((
                map(
                    tuple((
                        alt((
                            map("enable", |(_, span)| (ModifierKind::Enable, span)),
                            map("disable", |(_, span)| (ModifierKind::Disable, span)),
                        )),
                        value(BooleanSetting::Lazy, "lazy"),
                        Token::Semicolon,
                    )),
                    |((kind, span_start), value, (_, span_end))| {
                        let stmt = match kind {
                            ModifierKind::Enable => Stmt::Enable(value),
                            ModifierKind::Disable => Stmt::Disable(value),
                        };
                        (stmt, span_start.join(span_end))
                    },
                ),
                map(
                    tuple((
                        "let",
                        cut(Token::Identifier),
                        cut(Token::Equals),
                        cut(parse_or),
                        cut(Token::Semicolon),
                    )),
                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {
                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))
                    },
                ),
            ))),
            parse_or,
        ),
        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {
            if stmts.len() > 1 {
                let mut set = HashSet::new();
                for (stmt, _) in &stmts {
                    if let Stmt::Let(l) = stmt {
                        if set.contains(l.name()) {
                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));
                        }
                        set.insert(l.name());
                    }
                }
            }

            let span_end = rule.span();
            for (stmt, span) in stmts.into_iter().rev() {
                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));
            }
            Ok(rule)
        },
        nom::Err::Failure,
    )(input)
}
pub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        try_map(
            pair(Token::Not, opt(parse_fixes)),
            |(_, rule)| {
                if let Some(mut rule) = rule {
                    rule.negate()?;
                    Ok(rule)
                } else {
                    Err(ParseErrorKind::Expected("expression"))
                }
            },
            nom::Err::Failure,
        ),
        map(pair(parse_lookaround, parse_modified), |((kind, span), rule)| {
            let span = span.join(rule.span());
            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))
        }),
        try_map2(
            pair(parse_atom, many0(parse_repetition)),
            |(mut rule, repetitions)| {
                let mut prev_syntax = RepSyntax::ExplicitQuantifier;
                for (kind, quantifier, span, syntax) in repetitions {
                    if matches!(
                        (&prev_syntax, &syntax),
                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)
                    ) {
                        return Err(ParseErrorKind::Repetition(
                            RepetitionError::QuestionMarkAfterRepetition,
                        )
                        .at(span));
                    }
                    prev_syntax = syntax;

                    let span = rule.span().join(span);
                    rule =
                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));
                }
                Ok(rule)
            },
            nom::Err::Failure,
        ),
    ))(input)
}

pub(super) fn parse_lookaround<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (LookaroundKind, Span)> {
    alt((
        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),
        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),
    ))(input)
}

pub(super) enum RepSyntax {
    ExplicitQuantifier,
    QuestionMark,
    Other,
}

pub(super) fn parse_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {
    map(
        pair(
            alt((
                map(Token::QuestionMark, |(_, span)| {
                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)
                }),
                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),
                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),
                parse_braced_repetition,
            )),
            map(
                opt(alt((
                    map("greedy", |(_, span)| (Quantifier::Greedy, span)),
                    map("lazy", |(_, span)| (Quantifier::Lazy, span)),
                ))),
                |a| match a {
                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),
                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),
                },
            ),
        ),
        |((kind, span1, rs1), (quantifier, span2, rs2))| {
            (
                kind,
                quantifier,
                span1.join(span2),
                match (rs1, rs2) {
                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,
                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,
                    _ => RepSyntax::Other,
                },
            )
        },
    )(input)
}

pub(super) fn parse_braced_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {
    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {
        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)
    }

    map(
        tuple((
            Token::OpenBrace,
            cut(alt((
                try_map(
                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),
                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),
                    nom::Err::Failure,
                ),
                map(parse_u32, RepetitionKind::fixed),
            ))),
            cut(Token::CloseBrace),
        )),
        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),
    )(input)
}

pub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        parse_group,
        parse_string,
        parse_char_class,
        parse_boundary,
        parse_reference,
        map(parse_code_point, |(c, span)| {
            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))
        }),
        parse_range,
        parse_variable,
        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),
        err(|| ParseErrorKind::Expected("expression")),
    ))(input)
}