fn deserialize_empty<'a, V>(&'a mut self, _visitor: V) -> Result<V::Value>
    where
        V: Visitor<'de>,
    {
        Err(Error::subtype("Cannot decode empty type"))
    }

fn visit_byte_buf<E: de::Error>(self, value: Vec<u8>) -> DResult<E> {
        let (tag, mut bytes) = value.split_at(1);
        match tag[0] {
            0u8 => {
                let v = Int(num_bigint::BigInt::from_signed_bytes_le(bytes));
                Ok(IDLValue::Int(v))
            }
            1u8 => {
                let v = Nat(num_bigint::BigUint::from_bytes_le(bytes));
                Ok(IDLValue::Nat(v))
            }
            2u8 => {
                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;
                Ok(IDLValue::Principal(v))
            }
            4u8 => {
                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;
                Ok(IDLValue::Service(v))
            }
            5u8 => {
                use std::io::Read;
                let len = leb128::read::unsigned(&mut bytes).map_err(E::custom)? as usize;
                let mut buf = Vec::new();
                buf.resize(len, 0);
                bytes.read_exact(&mut buf).map_err(E::custom)?;
                let meth = String::from_utf8(buf).map_err(E::custom)?;
                let id = crate::Principal::try_from(bytes).map_err(E::custom)?;
                Ok(IDLValue::Func(id, meth))
            }
            3u8 => Ok(IDLValue::Reserved),
            _ => Err(de::Error::custom("unknown tag in visit_byte_buf")),
        }
    }
