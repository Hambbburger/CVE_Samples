    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {
        self.visited.insert(from);

        if !self.spreads.contains_key(from) {
            return;
        }

        self.path_indices.insert(from, path.len());

        for node in &self.spreads[from] {
            let name = &node.item;
            let index = self.path_indices.get(name).cloned();

            if let Some(index) = index {
                let err_pos = if index < path.len() {
                    path[index]
                } else {
                    node
                };

                self.errors
                    .push(RuleError::new(&error_message(name), &[err_pos.start]));
            } else if !self.visited.contains(name) {
                path.push(node);
                self.detect_from(name, path);
                path.pop();
            }
        }

        self.path_indices.remove(from);
    }
    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {
        assert!(self.current_fragment.is_none());

        let mut detector = CycleDetector {
            visited: HashSet::new(),
            spreads: &self.spreads,
            path_indices: HashMap::new(),
            errors: Vec::new(),
        };

        for frag in &self.fragment_order {
            if !detector.visited.contains(frag) {
                let mut path = Vec::new();
                detector.detect_from(frag, &mut path);
            }
        }

        ctx.append_errors(detector.errors);
    }
    fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {
        if let Scope::Fragment(name) = *from {
            if result.contains(name) {
                return;
            } else {
                result.insert(name);
            }
        }

        if let Some(spreads) = self.spreads.get(from) {
            for spread in spreads {
                self.find_reachable_fragments(&Scope::Fragment(spread), result)
            }
        }
    }
    fn find_used_vars(
        &self,
        from: &Scope<'a>,
        defined: &HashSet<&'a str>,
        used: &mut HashSet<&'a str>,
        visited: &mut HashSet<Scope<'a>>,
    ) {
        if visited.contains(from) {
            return;
        }

        visited.insert(from.clone());

        if let Some(used_vars) = self.used_variables.get(from) {
            for var in used_vars {
                if defined.contains(var) {
                    used.insert(var);
                }
            }
        }

        if let Some(spreads) = self.spreads.get(from) {
            for spread in spreads {
                self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);
            }
        }
    }
    fn collect_conflicts_between_fragments(
        &self,
        conflicts: &mut Vec<Conflict>,
        fragment_name1: &'a str,
        fragment_name2: &'a str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        // Early return on fragment recursion, as it makes no sense.
        // Fragment recursions are prevented by `no_fragment_cycles` validator.
        if fragment_name1 == fragment_name2 {
            return;
        }

        let fragment1 = match self.named_fragments.get(fragment_name1) {
            Some(f) => f,
            None => return,
        };

        let fragment2 = match self.named_fragments.get(fragment_name2) {
            Some(f) => f,
            None => return,
        };

        {
            if self.compared_fragments.borrow().contains(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            ) {
                return;
            }
        }

        {
            self.compared_fragments.borrow_mut().insert(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            );
        }

        let (field_map1, fragment_names1) =
            self.get_referenced_fields_and_fragment_names(fragment1, ctx);
        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment2, ctx);

        self.collect_conflicts_between(
            conflicts,
            mutually_exclusive,
            &field_map1,
            &field_map2,
            ctx,
        );

        for fragment_name2 in &fragment_names2 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }

        for fragment_name1 in &fragment_names1 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between_fields_and_fragment(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        let fragment = match self.named_fragments.get(fragment_name) {
            Some(f) => f,
            None => return,
        };

        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment, ctx);

        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);

        for fragment_name2 in fragment_names2 {
            // Early return on fragment recursion, as it makes no sense.
            // Fragment recursions are prevented by `no_fragment_cycles` validator.
            if fragment_name == fragment_name2 {
                return;
            }
            self.collect_conflicts_between_fields_and_fragment(
                conflicts,
                field_map,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between(
        &self,
        conflicts: &mut Vec<Conflict>,
        mutually_exclusive: bool,
        field_map1: &AstAndDefCollection<'a, S>,
        field_map2: &AstAndDefCollection<'a, S>,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        for (response_name, fields1) in field_map1.iter() {
            if let Some(fields2) = field_map2.get(response_name) {
                for field1 in fields1 {
                    for field2 in fields2 {
                        if let Some(conflict) = self.find_conflict(
                            response_name,
                            field1,
                            field2,
                            mutually_exclusive,
                            ctx,
                        ) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }
    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {
        self.visited.insert(from);

        if !self.spreads.contains_key(from) {
            return;
        }

        self.path_indices.insert(from, path.len());

        for node in &self.spreads[from] {
            let name = &node.item;
            let index = self.path_indices.get(name).cloned();

            if let Some(index) = index {
                let err_pos = if index < path.len() {
                    path[index]
                } else {
                    node
                };

                self.errors
                    .push(RuleError::new(&error_message(name), &[err_pos.start]));
            } else if !self.visited.contains(name) {
                path.push(node);
                self.detect_from(name, path);
                path.pop();
            }
        }

        self.path_indices.remove(from);
    }
    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {
        assert!(self.current_fragment.is_none());

        let mut detector = CycleDetector {
            visited: HashSet::new(),
            spreads: &self.spreads,
            path_indices: HashMap::new(),
            errors: Vec::new(),
        };

        for frag in &self.fragment_order {
            if !detector.visited.contains(frag) {
                let mut path = Vec::new();
                detector.detect_from(frag, &mut path);
            }
        }

        ctx.append_errors(detector.errors);
    }
    fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {
        if let Scope::Fragment(name) = *from {
            if result.contains(name) {
                return;
            } else {
                result.insert(name);
            }
        }

        if let Some(spreads) = self.spreads.get(from) {
            for spread in spreads {
                self.find_reachable_fragments(&Scope::Fragment(spread), result)
            }
        }
    }
    fn find_used_vars(
        &self,
        from: &Scope<'a>,
        defined: &HashSet<&'a str>,
        used: &mut HashSet<&'a str>,
        visited: &mut HashSet<Scope<'a>>,
    ) {
        if visited.contains(from) {
            return;
        }

        visited.insert(from.clone());

        if let Some(used_vars) = self.used_variables.get(from) {
            for var in used_vars {
                if defined.contains(var) {
                    used.insert(var);
                }
            }
        }

        if let Some(spreads) = self.spreads.get(from) {
            for spread in spreads {
                self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);
            }
        }
    }
    fn collect_conflicts_between_fragments(
        &self,
        conflicts: &mut Vec<Conflict>,
        fragment_name1: &'a str,
        fragment_name2: &'a str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        // Early return on fragment recursion, as it makes no sense.
        // Fragment recursions are prevented by `no_fragment_cycles` validator.
        if fragment_name1 == fragment_name2 {
            return;
        }

        let fragment1 = match self.named_fragments.get(fragment_name1) {
            Some(f) => f,
            None => return,
        };

        let fragment2 = match self.named_fragments.get(fragment_name2) {
            Some(f) => f,
            None => return,
        };

        {
            if self.compared_fragments.borrow().contains(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            ) {
                return;
            }
        }

        {
            self.compared_fragments.borrow_mut().insert(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            );
        }

        let (field_map1, fragment_names1) =
            self.get_referenced_fields_and_fragment_names(fragment1, ctx);
        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment2, ctx);

        self.collect_conflicts_between(
            conflicts,
            mutually_exclusive,
            &field_map1,
            &field_map2,
            ctx,
        );

        for fragment_name2 in &fragment_names2 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }

        for fragment_name1 in &fragment_names1 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between_fields_and_fragment(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        let fragment = match self.named_fragments.get(fragment_name) {
            Some(f) => f,
            None => return,
        };

        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment, ctx);

        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);

        for fragment_name2 in fragment_names2 {
            // Early return on fragment recursion, as it makes no sense.
            // Fragment recursions are prevented by `no_fragment_cycles` validator.
            if fragment_name == fragment_name2 {
                return;
            }
            self.collect_conflicts_between_fields_and_fragment(
                conflicts,
                field_map,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between(
        &self,
        conflicts: &mut Vec<Conflict>,
        mutually_exclusive: bool,
        field_map1: &AstAndDefCollection<'a, S>,
        field_map2: &AstAndDefCollection<'a, S>,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        for (response_name, fields1) in field_map1.iter() {
            if let Some(fields2) = field_map2.get(response_name) {
                for field1 in fields1 {
                    for field2 in fields2 {
                        if let Some(conflict) = self.find_conflict(
                            response_name,
                            field1,
                            field2,
                            mutually_exclusive,
                            ctx,
                        ) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }