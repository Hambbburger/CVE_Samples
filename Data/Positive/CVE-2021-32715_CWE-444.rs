fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)
                                         -> Result<T, ParseIntError> {
    use self::IntErrorKind::*;
    use self::ParseIntError as PIE;
    assert!(radix >= 2 && radix <= 36,
           "from_str_radix_int: must lie in the range `[2, 36]` - found {}",
           radix);
    if src.is_empty() {
        return Err(PIE { kind: Empty });
    }
    let is_signed_ty = T::from_u32(0) > T::min_value();
    // all valid digits are ascii, so we will just iterate over the utf8 bytes
    // and cast them to chars. .to_digit() will safely return None for anything
    // other than a valid ascii digit for a the given radix, including the first-byte
    // of multi-byte sequences
    let src = src.as_bytes();

    match (src[0], &src[1..])  {
        (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),
        (b'-', digits) if is_signed_ty => {
            // The number is negative
            let mut result = T::from_u32(0);
            for &c in digits {
                let x = match (c as char).to_digit(radix) {
                    Some(x) => x,
                    None => return Err(PIE { kind: InvalidDigit }),
                };
                result = match result.checked_mul(radix) {
                    Some(result) => result,
                    None => return Err(PIE { kind: Underflow }),
                };
                result = match result.checked_sub(x) {
                    Some(result) => result,
                    None => return Err(PIE { kind: Underflow }),
                };
            }
            Ok(result)
        },
        (c, digits) => {
            // The number is signed
            let mut result = match (c as char).to_digit(radix) {
                Some(x) => T::from_u32(x),
    
                None => return Err(PIE { kind: InvalidDigit }),
            };
            for &c in digits {
                let x = match (c as char).to_digit(radix) {
                    Some(x) => x,
                    None => return Err(PIE { kind: InvalidDigit }),
                };
                result = match result.checked_mul(radix) {
                    Some(result) => result,
                    None => return Err(PIE { kind: Overflow }),
                };
                result = match result.checked_add(x) {
                    Some(result) => result,
                    None => return Err(PIE { kind: Overflow }),
                };
            }
            Ok(result)
            
        }
    }
}
Path
Vulnerable Function 2
