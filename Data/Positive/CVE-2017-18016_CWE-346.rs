	fn is_web_proxy_token_valid(&self, token: &str) -> bool;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {
	fn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }
}
fn should_correctly_handle_long_label_when_splitted() {
	// given
	let (server, fetch) = serve_with_fetch("xolrg9fePeQyKLnL");

	// when
	let response = request(server,
		"\
			GET /styles.css?test=123 HTTP/1.1\r\n\
			Host: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://contribution.melonport.com/styles.css?test=123");
	fetch.assert_no_more_requests();
}
fn should_disallow_non_get_requests() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			POST / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Content-Type: application/json\r\n\
			Connection: close\r\n\
			\r\n\
			123\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 405 Method Not Allowed");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_fix_absolute_requests_based_on_referer() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET /styles.css HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			Referer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 302 Found");
	response.assert_header("Location", "/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css");

	fetch.assert_no_more_requests();
}
fn should_fix_absolute_requests_based_on_referer_in_url() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET /styles.css HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			Referer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 302 Found");
	response.assert_header("Location", "/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css");

	fetch.assert_no_more_requests();
}
fn should_return_error_on_invalid_protocol() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET /web/token/ftp/parity.io/ HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 400 Bad Request");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_return_error_on_invalid_token() {
	// given
	let (server, fetch) = serve_with_fetch("test");

	// when
	let response = request(server,
		"\
			GET / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 400 Bad Request");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_stream_web_content() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/");
	fetch.assert_no_more_requests();
}
fn should_support_base32_encoded_web_urls() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET /styles.css?test=123 HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/styles.css?test=123");
	fetch.assert_no_more_requests();
}
fn should_support_base32_encoded_web_urls_as_path() {
	// given
	let (server, fetch) = serve_with_fetch("token");

	// when
	let response = request(server,
		"\
			GET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/styles.css?test=123");
	fetch.assert_no_more_requests();
}
	fn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {
		let token_and_url = self.path.app_params.get(0)
			.map(|encoded| encoded.replace('.', ""))
			.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))
			.and_then(|data| String::from_utf8(data).ok())
			.ok_or_else(|| State::Error(ContentHandler::error(
				StatusCode::BadRequest,
				"Invalid parameter",
				"Couldn't parse given parameter:",
				self.path.app_params.get(0).map(String::as_str),
				self.embeddable_on.clone()
			)))?;

		let mut token_it = token_and_url.split('+');
		let token = token_it.next();
		let target_url = token_it.next();

		// Check if token supplied in URL is correct.
		match token {
			Some(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid Access Token", "Invalid or old web proxy access token supplied.", Some("Try refreshing the page."), self.embeddable_on.clone()
				)));
			}
		}

		// Validate protocol
		let mut target_url = match target_url {
			Some(url) if url.starts_with("http://") || url.starts_with("https://") => url.to_owned(),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid Protocol", "Invalid protocol used.", None, self.embeddable_on.clone()
				)));
			}
		};

		if !target_url.ends_with("/") {
			target_url = format!("{}/", target_url);
		}

		// TODO [ToDr] Should just use `path.app_params`
		let (path, query) = match (&url, self.path.using_dapps_domains) {
			(&Some(ref url), true) => (&url.path[..], &url.query),
			(&Some(ref url), false) => (&url.path[2..], &url.query),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid URL", "Couldn't parse URL", None, self.embeddable_on.clone()
				)));
			}
		};

		let query = match *query {
			Some(ref query) => format!("?{}", query),
			None => "".into(),
		};

		Ok(format!("{}{}{}", target_url, path.join("/"), query))
	}
	pub fn dapps_middleware(
		deps: Dependencies,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let signer = deps.signer;
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		let web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));

		Ok(parity_dapps::Middleware::dapps(
			parity_remote,
			deps.ui_address,
			dapps_path,
			extra_dapps,
			dapps_domain,
			deps.contract_client,
			deps.sync_status,
			web_proxy_tokens,
			deps.fetch,
		))
	}
	pub fn generate_web_proxy_access_token(&self) -> String {
		let token = random_string(16);
		let mut tokens = self.web_proxy_tokens.lock();
		tokens.prune();
		tokens.insert(token.clone(), ());
		token
	}
	pub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {
		self.web_proxy_tokens.lock().contains_key(&token)
	}
	fn generate_web_proxy_token(&self) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token())
	}