async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3000).into();
    let counter = Arc::new(AtomicU64::new(0));

    let mut listener = tls_listener::builder(tls_acceptor())
        .max_handshakes(10)
        .listen(TcpListener::bind(addr).await.expect("Failed to bind port"));

    let (tx, mut rx) = mpsc::channel::<Acceptor>(1);
    let http = http1::Builder::new();
    loop {
        tokio::select! {
            conn = listener.accept() => {
                match conn {
                    Ok((conn, remote_addr)) => {
                        let http = http.clone();
                        let tx = tx.clone();
                        let counter = counter.clone();
                        tokio::spawn(async move {
                            let svc = service_fn(move |request| handle_request(tx.clone(), counter.clone(), request));
                            if let Err(err) = http.serve_connection(TokioIo::new(conn), svc).await {
                                eprintln!("Application error (client address: {remote_addr}): {err}");
                            }
                        });
                    },
                    Err(e) => {
                        if let Some(remote_addr) = e.peer_addr() {
                            eprint!("[client {remote_addr}] ");
                        }
                        eprintln!("Bad connection: {}", e);
                    }
                }
            },
            message = rx.recv() => {
                // Certificate is loaded on another task; we don't want to block the listener loop
                let acceptor = message.expect("Channel should not be closed");
                println!("Rotating certificate...");
                listener.replace_acceptor(acceptor);
            }
        }
    }
}

pub fn poll_accept(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<<Self as Stream>::Item> {
        let mut this = self.project();

        while this.waiting.len() < *this.max_handshakes {
            match this.listener.as_mut().poll_accept(cx) {
                Poll::Pending => break,
                Poll::Ready(Ok((conn, addr))) => {
                    this.waiting.push(Waiting {
                        inner: timeout(*this.timeout, this.tls.accept(conn)),
                        peer_addr: Some(addr),
                    });
                }
                Poll::Ready(Err(e)) => {
                    return Poll::Ready(Err(Error::ListenerError(e)));
                }
            }
        }

        match this.waiting.poll_next_unpin(cx) {
            Poll::Ready(Some(result)) => Poll::Ready(result),
            // If we don't have anything waiting yet,
            // then we are still pending,
            Poll::Ready(None) | Poll::Pending => Poll::Pending,
        }
    }

pub fn max_handshakes(&mut self, max: usize) -> &mut Self {
        self.max_handshakes = max;
        self
    }

pub fn listen<A: AsyncAccept>(&self, listener: A) -> TlsListener<A, T>
    where
        T: AsyncTls<A::Connection>,
    {
        TlsListener {
            listener,
            tls: self.tls.clone(),
            waiting: FuturesUnordered::new(),
            max_handshakes: self.max_handshakes,
            timeout: self.handshake_timeout,
        }
    }

pub fn builder<T>(tls: T) -> Builder<T> {
    Builder {
        tls,
        max_handshakes: DEFAULT_MAX_HANDSHAKES,
        handshake_timeout: DEFAULT_HANDSHAKE_TIMEOUT,
    }
}
