pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {
        let boxed = Box::into_raw(Box::new(AuxData {
            id: TypeId::of::<T>(),
            value,
        }));
        unsafe {
            ffi::sqlite3_set_auxdata(
                self.ctx,
                arg,
                boxed as *mut c_void,
                Some(free_boxed_value::<AuxData<T>>),
                
            )
        };
    }

pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {
        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };
    
        if p.is_null() {
            Ok(None)
        } else {
            let id = unsafe { (*p).id };
            if TypeId::of::<T>() != id {
                Err(Error::GetAuxWrongType)
            } else {
                Ok(Some(unsafe { &(*p).value }))
            }
            
        }
    }

fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {
        assert_eq!(ctx.len(), 2, "called with unexpected number of arguments");

        let saved_re: Option<&Regex> = ctx.get_aux(0)?;
        let new_re = match saved_re {
            None => {
                let s = ctx.get::<String>(0)?;
                match Regex::new(&s) {
                    Ok(r) => Some(r),
                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),
                }
            }
            Some(_) => None,
        };
        

        let is_match = {
            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());

            let text = ctx
                .get_raw(1)
                .as_str()
                .map_err(|e| Error::UserFunctionError(e.into()))?;

            re.is_match(text)
        };

        if let Some(re) = new_re {
            ctx.set_aux(0, re);
        }

        Ok(is_match)
    }
