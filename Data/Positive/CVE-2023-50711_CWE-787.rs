Cargo.toml
[package]
name = "vmm-sys-util"
version = "0.11.2"
authors = ["Intel Virtualization Team <vmm-maintainers@intel.com>"]
description = "A system utility set"
repository = "https://github.com/rust-vmm/vmm-sys-util"

[dev-dependencies]
serde_json = "1.0.9"

fn set_len(&mut self, len: usize);

pub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {
        if num_elements > T::max_len() {
            return Err(Error::SizeLimitExceeded);
        }
        let required_mem_allocator_capacity =
            FamStructWrapper::<T>::mem_allocator_len(num_elements)
                .ok_or(Error::SizeLimitExceeded)?;
        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);
        mem_allocator.push(T::default());
        for _ in 1..required_mem_allocator_capacity {
            // SAFETY: Safe as long T follows the requirements of being POD.
            mem_allocator.push(unsafe { mem::zeroed() })
        }
        mem_allocator[0].set_len(num_elements);

        Ok(FamStructWrapper { mem_allocator })
    }

pub fn as_mut_fam_struct(&mut self) -> &mut T {
    // Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.
    
    }

fn set_len(&mut self, len: usize) -> Result<(), Error> {
        let additional_elements = isize::try_from(len)
            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))
            .map_err(|_| Error::SizeLimitExceeded)?;
        // If len == self.len there's nothing to do.
        if additional_elements == 0 {
            return Ok(());
        }
        // If the len needs to be increased:
        if additional_elements > 0 {
            // Check if the new len is valid.
            if len > T::max_len() {
                return Err(Error::SizeLimitExceeded);
            }
            // Reserve additional capacity.
            self.reserve(additional_elements as usize)?;
        }
        let current_mem_allocator_len = self.mem_allocator.len();
        let required_mem_allocator_len =
            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;
        // Update the len of the `mem_allocator`.
        // SAFETY: This is safe since enough capacity has been reserved.
        unsafe {
            self.mem_allocator.set_len(required_mem_allocator_len);
        }
        // Zero-initialize the additional elements if any.
        for i in current_mem_allocator_len..required_mem_allocator_len {
            // SAFETY: Safe as long as the trait is only implemented for POD. This is a requirement
            // for the trait implementation.
            self.mem_allocator[i] = unsafe { mem::zeroed() }
        }
        // Update the len of the underlying `FamStruct`.
        self.as_mut_fam_struct().set_len(len);

        // If the len needs to be decreased, deallocate unnecessary memory
        if additional_elements < 0 {
            self.mem_allocator.shrink_to_fit();
        }
        Ok(())
    }

fn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>
            where
                V: SeqAccess<'de>,
            {
                use serde::de::Error;

                let header = seq

                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())
                    .map_err(|e| V::Error::custom(format!("{:?}", e)))?;
                result.mem_allocator[0] = header;
                Ok(result)
            }

fn set_len(&mut self, len: usize) {
                self.$field_name = len as $field_type;
            }
 #[derive(Default, PartialEq, Eq)]
