use std::ops::Shl;
pub fn generate_private_key(&mut self) -> BigUint {
        let q = (&self.prime_num - &BigUint::from(1u8)) / &BigUint::from(2u8);
        let mut rng = rand::thread_rng();
        self.private_key = rng.gen_biguint((self.exp_size * 8) - 2u64).shl(1);
        self.private_key.clone()
    }


#[doc(hidden)]
    fn server_dh(&mut self, exchange: &mut Exchange, payload: &[u8]) -> Result<(), crate::Error> {
        debug!("server_dh");
        let client_pubkey = {
            if payload.first() != Some(&msg::KEX_ECDH_INIT) {
                return Err(crate::Error::Inconsistent);
            }
            #[allow(clippy::indexing_slicing)] // length checked
            let pubkey_len = BigEndian::read_u32(&payload[1..]) as usize;
            if payload.len() < 5 + pubkey_len {
                return Err(crate::Error::Inconsistent);
            }
            &payload
                .get(5..(5 + pubkey_len))
                .ok_or(crate::Error::Inconsistent)?
        };

        debug!("client_pubkey: {:?}", client_pubkey);

        self.dh.generate_private_key();
        let server_pubkey = biguint_to_mpint(&self.dh.generate_public_key());

        // fill exchange.
        exchange.server_ephemeral.clear();
        exchange.server_ephemeral.extend(&server_pubkey);

        let shared = self
            .dh
            .compute_shared_secret(DH::decode_public_key(client_pubkey));
        self.shared_secret = Some(biguint_to_mpint(&shared));
        Ok(())
    }

#[doc(hidden)]
    fn client_dh(
        &mut self,
        client_ephemeral: &mut CryptoVec,
        buf: &mut CryptoVec,
    ) -> Result<(), crate::Error> {
        self.dh.generate_private_key();
        let client_pubkey = biguint_to_mpint(&self.dh.generate_public_key());

        // fill exchange.
        client_ephemeral.clear();
        client_ephemeral.extend(&client_pubkey);

        buf.push(msg::KEX_ECDH_INIT);
        buf.extend_ssh_string(&client_pubkey);

        Ok(())
    }

    fn compute_shared_secret(&mut self, remote_pubkey_: &[u8]) -> Result<(), crate::Error> {
        let remote_pubkey = DH::decode_public_key(remote_pubkey_);

        self.shared_secret = Some(biguint_to_mpint(&shared));
        Ok(())
    }
