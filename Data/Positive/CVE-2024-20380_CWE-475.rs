pub unsafe extern "C" fn new_css_image_extractor(
    file_bytes: *const c_char,
) -> sys::css_image_extractor_t {
    let css_input = if file_bytes.is_null() {
        warn!("{} is NULL", stringify!(file_bytes));
        return 0 as sys::css_image_extractor_t;
    } else {
        #[allow(unused_unsafe)]
        unsafe { CStr::from_ptr(file_bytes) }.to_string_lossy()
    };

    if let Ok(extractor) = CssImageExtractor::new(&css_input) {
        Box::into_raw(Box::new(extractor)) as sys::css_image_extractor_t
    } else {
        0 as sys::css_image_extractor_t
    }
}
      

pub extern "C" fn free_css_image_extractor(extractor: sys::css_image_extractor_t) {
    if extractor.is_null() {
        warn!("Attempted to free an image extractor pointer. Please report this at: https://github.com/Cisco-Talos/clamav/issues");
    } else {
        let _ = unsafe { Box::from_raw(extractor as *mut CssImageExtractor) };
    }
}


pub unsafe extern "C" fn css_image_extract_next(
    extractor: sys::css_image_extractor_t,
    image_out: *mut *const u8,
    image_out_len: *mut usize,
    image_out_handle: *mut sys::css_image_handle_t,
) -> bool {
    let mut extractor = ManuallyDrop::new(Box::from_raw(extractor as *mut CssImageExtractor));

    let image_result = extractor.next();
    match image_result {
        Some(image) => {
            *image_out = image.as_ptr();
            *image_out_len = image.len();
            *image_out_handle = Box::into_raw(Box::new(image)) as sys::css_image_handle_t;
            true
        }
        None => false,
    }
}


pub extern "C" fn free_extracted_image(image: sys::css_image_handle_t) {
    if image.is_null() {
        warn!("Attempted to free an image pointer. Please report this at: https://github.com/Cisco-Talos/clamav/issues");
    } else {
        let _ = unsafe { Box::from_raw(image as *mut Vec<u8>) };
    }
}
