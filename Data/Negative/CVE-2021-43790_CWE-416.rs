    fn drop(&mut self) {
        if self.needs_inst_drop {
            unsafe {
                let inst = self.inst.as_mut();

                // The `inst.alloc` field manages the memory of the instance
                // itself. Note, though, that this field is in a `ManuallyDrop`
                // so it won't get dropped automatically in `drop_in_place`.
                // This is the point where we take over that precise drop.
                //
                // By using `take` here we're basically calling `ptr::read`
                // which "duplicates" the `alloc` since the `alloc` local
                // variable here is the exact same as `inst.alloc`. All we do
                // with `inst`, though, is call `drop_in_place`, which
                // invalidates every other field in `inst`.
                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);

                // drop the actual instance
                std::ptr::drop_in_place(inst);

                // Now that we're 100% done with the instance, destructors and
                // all, we can release the memory of the instance back to the
                // original allocator from whence it came (be it mmap or uffd
                // based). This will run the "official" destructor for `Alloc`
                // which internally does the release. Note that after this
                // operation the `inst` pointer is invalid and can no longer be
                // used.
                drop(alloc);
            }
        }
    }