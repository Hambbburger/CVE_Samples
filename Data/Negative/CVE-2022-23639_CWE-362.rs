pub fn fetch_add(&self, val: $t) -> $t {
                
                if can_transmute::<$t, $atomic>() {
                    let a = unsafe { &*(self.value.get() as *const $atomic) };
                    a.fetch_add(val, Ordering::AcqRel)
                } else {
                    #[cfg(crossbeam_loom)]
                    {
                        let _ = val;
                        unimplemented!("loom does not support non-atomic atomic ops");
                    }
                    #[cfg(not(crossbeam_loom))]
                    {
                        let _guard = lock(self.value.get() as usize).write();
                        let value = unsafe { &mut *(self.value.get()) };
                        let old = *value;
                        *value = value.wrapping_add(val);
                        old
                    }
                }
            }

pub fn fetch_sub(&self, val: $t) -> $t {
                if can_transmute::<$t, $atomic>() {
                    let a = unsafe { &*(self.value.get() as *const $atomic) };
                    a.fetch_sub(val, Ordering::AcqRel)
                } else {
                    #[cfg(crossbeam_loom)]
                    {
                        let _ = val;
                        unimplemented!("loom does not support non-atomic atomic ops");
                    }
                    #[cfg(not(crossbeam_loom))]
                    {
                        let _guard = lock(self.value.get() as usize).write();
                        let value = unsafe { &mut *(self.value.get()) };
                        let old = *value;
                        *value = value.wrapping_sub(val);
                        old
                    }
                }
            }

pub fn fetch_and(&self, val: $t) -> $t {
                
                if can_transmute::<$t, $atomic>() {
                    let a = unsafe { &*(self.value.get() as *const $atomic) };
                    a.fetch_and(val, Ordering::AcqRel)
                } else {
                    #[cfg(crossbeam_loom)]
                    {
                        let _ = val;
                        unimplemented!("loom does not support non-atomic atomic ops");
                    }
                    #[cfg(not(crossbeam_loom))]
                    {
                        let _guard = lock(self.value.get() as usize).write();
                        let value = unsafe { &mut *(self.value.get()) };
                        let old = *value;
                        *value &= val;
                        old
                    }
                }
            }

pub fn fetch_or(&self, val: $t) -> $t {
                
                if can_transmute::<$t, $atomic>() {
                    let a = unsafe { &*(self.value.get() as *const $atomic) };
                    a.fetch_or(val, Ordering::AcqRel)
                } else {
                    #[cfg(crossbeam_loom)]
                    {
                        let _ = val;
                        unimplemented!("loom does not support non-atomic atomic ops");
                    }
                    #[cfg(not(crossbeam_loom))]
                    {
                        let _guard = lock(self.value.get() as usize).write();
                        let value = unsafe { &mut *(self.value.get()) };
                        let old = *value;
                        *value |= val;
                        old
                    }
                }
            }

pub fn fetch_xor(&self, val: $t) -> $t {
                
                if can_transmute::<$t, $atomic>() {
                    let a = unsafe { &*(self.value.get() as *const $atomic) };
                    a.fetch_xor(val, Ordering::AcqRel)
                } else {
                    #[cfg(crossbeam_loom)]
                    {
                        let _ = val;
                        unimplemented!("loom does not support non-atomic atomic ops");
                    }
                    #[cfg(not(crossbeam_loom))]
                    {
                        let _guard = lock(self.value.get() as usize).write();
                        let value = unsafe { &mut *(self.value.get()) };
                        let old = *value;
                        *value ^= val;
                        old
                    }
                }
            }
