fn decode_aligned(b64ch: u8, decode_table: &[u8; 256]) -> u8 {
    let mut result: u8 = 0x00;
    let mut mask: u8;
    let idx: [u8;2] = [ b64ch % 64, b64ch % 64 + 64];
    for i in 0..2  {
        mask = 0xFF ^ (((idx[i] == b64ch) as i8 - 1) as u8);
        result = result | (decode_table[idx[i] as usize] & mask);
    }
    result
}
fn decode_chunk(
    input: &[u8],
    index_at_start_of_input: usize,
    decode_table: &[u8; 256],
    output: &mut [u8],
) -> Result<(), DecodeError> {
    let mut accum: u64;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[0] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[0], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));
    }
    accum = (morsel as u64) << 58;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[1] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[1], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 1,
            input[1],
        ));
    }
    accum |= (morsel as u64) << 52;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[2] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[2], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 2,
            input[2],
        ));
    }
    accum |= (morsel as u64) << 46;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[3] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[3], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 3,
            input[3],
        ));
    }
    accum |= (morsel as u64) << 40;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[4] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[4], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 4,
            input[4],
        ));
    }
    accum |= (morsel as u64) << 34;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[5] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[5], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 5,
            input[5],
        ));
    }
    accum |= (morsel as u64) << 28;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[6] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[6], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 6,
            input[6],
        ));
    }
    accum |= (morsel as u64) << 22;

    #[cfg(not(feature = "slow_but_safe"))]
    let morsel = decode_table[input[7] as usize];
    #[cfg(feature = "slow_but_safe")]
    let morsel = decode_aligned(input[7], decode_table);
    if morsel == tables::INVALID_VALUE {
        return Err(DecodeError::InvalidByte(
            index_at_start_of_input + 7,
            input[7],
        ));
    }
    accum |= (morsel as u64) << 16;

    write_u64(output, accum);

    Ok(())
}
    fn encode_table(self) -> &'static [u8; 64] {
        match self {
            CharacterSet::Standard => tables::STANDARD_ENCODE,
            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,
            CharacterSet::Crypt => tables::CRYPT_ENCODE,
            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,
            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,
            CharacterSet::BinHex => tables::BINHEX_ENCODE,
        }
    }

    fn decode_table(self) -> &'static [u8; 256] {
        match self {
            CharacterSet::Standard => &tables::STANDARD_DECODE_HOLDER.data,
            CharacterSet::UrlSafe => &tables::URL_SAFE_DECODE_HOLDER.data,
            CharacterSet::Crypt => &tables::CRYPT_DECODE_HOLDER.data,
            CharacterSet::Bcrypt => &tables::BCRYPT_DECODE_HOLDER.data,
            CharacterSet::ImapMutf7 => &tables::IMAP_MUTF7_DECODE_HOLDER.data,
            CharacterSet::BinHex => &tables::BINHEX_DECODE_HOLDER.data,
        }
    }
fn alignment_check() {
    let p: *const u8 = STANDARD_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = URL_SAFE_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = CRYPT_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = BCRYPT_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = IMAP_MUTF7_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
    let p: *const u8 = BINHEX_DECODE_HOLDER.data.as_ptr();
    assert_eq!((p as u64) % 64, 0);
}