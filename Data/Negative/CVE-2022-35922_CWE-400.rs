	pub fn new(mask: bool) -> Receiver {
    		Receiver::new_with_limits(mask, DEFAULT_MAX_DATAFRAME_SIZE, DEFAULT_MAX_MESSAGE_SIZE)
    	}

    	/// Create a new Receiver using the specified Reader, with configurable limits
    	///
    	/// Sizes should not be larger than `u32::MAX`.
    	///
    	/// Note that `max_message_size` denotes message size where no new dataframes would be read,
    	/// so actual maximum message size is larger.
    	pub fn new_with_limits(mask: bool, max_dataframe_size: usize, max_message_size: usize) -> Receiver {
    		let max_dataframe_size: u32 = max_dataframe_size.min(u32::MAX as usize) as u32;
    		let max_message_size: u32 = max_message_size.min(u32::MAX as usize) as u32;
    		Receiver {
    			buffer: Vec::new(),
    			mask,
    			max_dataframe_size,
    			max_message_size,
    		}
    	}
    fn recv_dataframe<R>(&mut self, reader: &mut R) -> WebSocketResult<DataFrame>
    	where
    		R: Read,
    	{
    		DataFrame::read_dataframe_with_limit(reader, self.mask, self.max_dataframe_size as usize)
    	}

    	/// Returns the data frames that constitute one message.
    	fn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>
    	where
    		R: Read,
    	{
    		let mut current_message_length : usize = self.buffer.iter().map(|x|x.data.len()).sum();
    		let mut finished = if self.buffer.is_empty() {
    			let first = self.recv_dataframe(reader)?;

    			if first.opcode == Opcode::Continuation {
    				return Err(WebSocketError::ProtocolError(
    					"Unexpected continuation data frame opcode",
    				));
    			}

    			let finished = first.finished;
    			current_message_length += first.data.len();
    			self.buffer.push(first);
    			finished
    		} else {
    			false
    		};
    		while !finished {
    			let next = self.recv_dataframe(reader)?;
    			finished = next.finished;

    			match next.opcode as u8 {
    				// Continuation opcode
    				0 => {
    					current_message_length += next.data.len();
    					self.buffer.push(next)
    				}
    				// Control frame
    				8..=15 => {
    					return Ok(vec![next]);
    				}
    				// Others
    				_ => {
    					return Err(WebSocketError::ProtocolError(
    						"Unexpected data frame opcode",
    					));
    				}
    			}

    			if !finished {
    				if self.buffer.len() >= MAX_DATAFRAMES_IN_ONE_MESSAGE {
    					return Err(WebSocketError::ProtocolError(
    						"Exceeded count of data frames in one WebSocket message",
    					));
    				}
    				if current_message_length >= self.max_message_size as usize {
    					return Err(WebSocketError::ProtocolError(
    						"Exceeded maximum WebSocket message size",
    					));
    				}
    			}
    		}

    		Ok(::std::mem::replace(&mut self.buffer, Vec::new()))
    	}

	pub fn read_dataframe_with_limit<R>(reader: &mut R, should_be_masked: bool, limit: usize) -> WebSocketResult<Self>
	where
		R: Read,
	{
		let header = dfh::read_header(reader)?;

		if header.len > limit as u64 {
			return Err(io::Error::new(io::ErrorKind::InvalidData, "exceeded DataFrame length limit").into());
		}
		let mut data: Vec<u8> = Vec::with_capacity(header.len as usize);
		let read = reader.take(header.len).read_to_end(&mut data)?;
		if (read as u64) < header.len {
			return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "incomplete payload").into());
		}

		DataFrame::read_dataframe_body(header, data, should_be_masked)
	}