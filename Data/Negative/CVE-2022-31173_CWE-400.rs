    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {
        assert!(self.current_fragment.is_none());

        let mut detector = CycleDetector {
            visited: HashSet::new(),
            spreads: &self.spreads,
            errors: Vec::new(),
        };

        for frag in &self.fragment_order {
            if !detector.visited.contains(frag) {
                detector.detect_from(frag);
            }
        }

        ctx.append_errors(detector.errors);
    }
    fn find_undef_vars_inner(
        &'a self,
        scope: &Scope<'a>,
        defined: &HashSet<&'a str>,
        unused: &mut Vec<&'a Spanning<&'a str>>,
        visited: &mut HashSet<Scope<'a>>,
    ) -> Option<&'a Vec<&'a str>> {
        if visited.contains(scope) {
            return None;
        }

        visited.insert(scope.clone());

        if let Some(used_vars) = self.used_variables.get(scope) {
            for var in used_vars {
                if !defined.contains(&var.item) {
                    unused.push(var);
                }
            }
        }

        self.spreads.get(scope)
    }
    fn collect_conflicts_between_fragments(
        &self,
        conflicts: &mut Vec<Conflict>,
        fragment_name1: &'a str,
        fragment_name2: &'a str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        // Early return on fragment recursion, as it makes no sense.
        // Fragment recursions are prevented by `no_fragment_cycles` validator.
        if fragment_name1 == fragment_name2 {
            return;
        }

        let fragment1 = match self.named_fragments.get(fragment_name1) {
            Some(f) => f,
            None => return,
        };

        let fragment2 = match self.named_fragments.get(fragment_name2) {
            Some(f) => f,
            None => return,
        };

        {
            if self.compared_fragments.borrow().contains(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            ) {
                return;
            }
        }

        {
            self.compared_fragments.borrow_mut().insert(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            );
        }

        let (field_map1, fragment_names1) =
            self.get_referenced_fields_and_fragment_names(fragment1, ctx);
        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment2, ctx);

        self.collect_conflicts_between(
            conflicts,
            mutually_exclusive,
            &field_map1,
            &field_map2,
            ctx,
        );

        for fragment_name2 in &fragment_names2 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }

        for fragment_name1 in &fragment_names1 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between_fields_and_fragment(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        let mut to_check = Vec::new();
        if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(
            conflicts,
            field_map,
            fragment_name,
            mutually_exclusive,
            ctx,
        ) {
            to_check.push((fragment_name, fragments))
        }

        while let Some((fragment_name, fragment_names2)) = to_check.pop() {
            for fragment_name2 in fragment_names2 {
                // Early return on fragment recursion, as it makes no sense.
                // Fragment recursions are prevented by `no_fragment_cycles` validator.
                if fragment_name == fragment_name2 {
                    return;
                }
                if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(
                    conflicts,
                    field_map,
                    fragment_name2,
                    mutually_exclusive,
                    ctx,
                ) {
                    to_check.push((fragment_name2, fragments));
                };
            }
        }
    }

    /// This function should be called only inside
    /// [`Self::collect_conflicts_between_fields_and_fragment()`], as it's a
    /// recursive function using heap instead of a stack. So, instead of the
    /// recursive call, we return a [`Vec`] that is visited inside
    /// [`Self::collect_conflicts_between_fields_and_fragment()`].
    fn collect_conflicts_between_fields_and_fragment_inner(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) -> Option<Vec<&'a str>>
    where
        S: ScalarValue,
    {
        let fragment = self.named_fragments.get(fragment_name)?;

        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment, ctx);

        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);

        Some(fragment_names2)
    }

    fn collect_conflicts_between(
        &self,
        conflicts: &mut Vec<Conflict>,
        mutually_exclusive: bool,
        field_map1: &AstAndDefCollection<'a, S>,
        field_map2: &AstAndDefCollection<'a, S>,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        for (response_name, fields1) in field_map1.iter() {
            if let Some(fields2) = field_map2.get(response_name) {
                for field1 in fields1 {
                    for field2 in fields2 {
                        if let Some(conflict) = self.find_conflict(
                            response_name,
                            field1,
                            field2,
                            mutually_exclusive,
                            ctx,
                        ) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }
    fn dummy() -> bool {
        false
    }
async fn test() {
    const PERM: &str = "abcefghijk";
    const CIRCLE_SIZE: usize = 7500;

    let query = iter::once(format!("query {{ ...{PERM} }} "))
        .chain(
            PERM.chars()
                .permutations(PERM.len())
                .map(|vec| vec.into_iter().collect::<String>())
                .take(CIRCLE_SIZE)
                .collect::<Vec<_>>()
                .into_iter()
                .circular_tuple_windows::<(_, _)>()
                .map(|(cur, next)| format!("fragment {cur} on Query {{ ...{next} }} ")),
        )
        .collect::<String>();

    let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());
    let _ = juniper::execute(&query, None, &schema, &graphql_vars! {}, &())
        .await
        .unwrap_err();
}
    fn dummy() -> bool {
        false
    }
async fn test() {
    const PERM: &str = "abcefghijk";
    const CIRCLE_SIZE: usize = 7500;

    let query = iter::once(format!("query {{ ...{PERM} }} "))
        .chain(
            PERM.chars()
                .permutations(PERM.len())
                .map(|vec| vec.into_iter().collect::<String>())
                .take(CIRCLE_SIZE)
                .collect::<Vec<_>>()
                .into_iter()
                .circular_tuple_windows::<(_, _)>()
                .map(|(cur, next)| format!("fragment {cur} on Query {{ ...{next} }} ")),
        )
        .collect::<String>();

    let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());
    let _ = juniper::execute(&query, None, &schema, &Variables::new(), &())
        .await
        .unwrap_err();
}
    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {
        assert!(self.current_fragment.is_none());

        let mut detector = CycleDetector {
            visited: HashSet::new(),
            spreads: &self.spreads,
            errors: Vec::new(),
        };

        for frag in &self.fragment_order {
            if !detector.visited.contains(frag) {
                detector.detect_from(frag);
            }
        }

        ctx.append_errors(detector.errors);
    }
    fn find_undef_vars_inner(
        &'a self,
        scope: &Scope<'a>,
        defined: &HashSet<&'a str>,
        unused: &mut Vec<&'a Spanning<&'a str>>,
        visited: &mut HashSet<Scope<'a>>,
    ) -> Option<&'a Vec<&'a str>> {
        if visited.contains(scope) {
            return None;
        }

        visited.insert(scope.clone());

        if let Some(used_vars) = self.used_variables.get(scope) {
            for var in used_vars {
                if !defined.contains(&var.item) {
                    unused.push(var);
                }
            }
        }

        self.spreads.get(scope)
    }
    fn collect_conflicts_between_fragments(
        &self,
        conflicts: &mut Vec<Conflict>,
        fragment_name1: &'a str,
        fragment_name2: &'a str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        // Early return on fragment recursion, as it makes no sense.
        // Fragment recursions are prevented by `no_fragment_cycles` validator.
        if fragment_name1 == fragment_name2 {
            return;
        }

        let fragment1 = match self.named_fragments.get(fragment_name1) {
            Some(f) => f,
            None => return,
        };

        let fragment2 = match self.named_fragments.get(fragment_name2) {
            Some(f) => f,
            None => return,
        };

        {
            if self.compared_fragments.borrow().contains(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            ) {
                return;
            }
        }

        {
            self.compared_fragments.borrow_mut().insert(
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
            );
        }

        let (field_map1, fragment_names1) =
            self.get_referenced_fields_and_fragment_names(fragment1, ctx);
        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment2, ctx);

        self.collect_conflicts_between(
            conflicts,
            mutually_exclusive,
            &field_map1,
            &field_map2,
            ctx,
        );

        for fragment_name2 in &fragment_names2 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }

        for fragment_name1 in &fragment_names1 {
            self.collect_conflicts_between_fragments(
                conflicts,
                fragment_name1,
                fragment_name2,
                mutually_exclusive,
                ctx,
            );
        }
    }

    fn collect_conflicts_between_fields_and_fragment(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        let mut to_check = Vec::new();
        if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(
            conflicts,
            field_map,
            fragment_name,
            mutually_exclusive,
            ctx,
        ) {
            to_check.push((fragment_name, fragments))
        }

        while let Some((fragment_name, fragment_names2)) = to_check.pop() {
            for fragment_name2 in fragment_names2 {
                // Early return on fragment recursion, as it makes no sense.
                // Fragment recursions are prevented by `no_fragment_cycles` validator.
                if fragment_name == fragment_name2 {
                    return;
                }
                if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(
                    conflicts,
                    field_map,
                    fragment_name2,
                    mutually_exclusive,
                    ctx,
                ) {
                    to_check.push((fragment_name2, fragments));
                };
            }
        }
    }

    /// This function should be called only inside
    /// [`Self::collect_conflicts_between_fields_and_fragment()`], as it's a
    /// recursive function using heap instead of a stack. So, instead of the
    /// recursive call, we return a [`Vec`] that is visited inside
    /// [`Self::collect_conflicts_between_fields_and_fragment()`].
    fn collect_conflicts_between_fields_and_fragment_inner(
        &self,
        conflicts: &mut Vec<Conflict>,
        field_map: &AstAndDefCollection<'a, S>,
        fragment_name: &str,
        mutually_exclusive: bool,
        ctx: &ValidatorContext<'a, S>,
    ) -> Option<Vec<&'a str>>
    where
        S: ScalarValue,
    {
        let fragment = self.named_fragments.get(fragment_name)?;

        let (field_map2, fragment_names2) =
            self.get_referenced_fields_and_fragment_names(fragment, ctx);

        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);

        Some(fragment_names2)
    }

    fn collect_conflicts_between(
        &self,
        conflicts: &mut Vec<Conflict>,
        mutually_exclusive: bool,
        field_map1: &AstAndDefCollection<'a, S>,
        field_map2: &AstAndDefCollection<'a, S>,
        ctx: &ValidatorContext<'a, S>,
    ) where
        S: ScalarValue,
    {
        for (response_name, fields1) in field_map1.iter() {
            if let Some(fields2) = field_map2.get(response_name) {
                for field1 in fields1 {
                    for field2 in fields2 {
                        if let Some(conflict) = self.find_conflict(
                            response_name,
                            field1,
                            field2,
                            mutually_exclusive,
                            ctx,
                        ) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }