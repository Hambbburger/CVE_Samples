fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)
                                         -> Result<T, ParseIntError> {
    use self::IntErrorKind::*;
    use self::ParseIntError as PIE;
    assert!(radix >= 2 && radix <= 36,
           "from_str_radix_int: must lie in the range `[2, 36]` - found {}",
           radix);
    if src.is_empty() {
        return Err(PIE { kind: Empty });
    }
    let is_signed_ty = T::from_u32(0) > T::min_value();
    // all valid digits are ascii, so we will just iterate over the utf8 bytes
    // and cast them to chars. .to_digit() will safely return None for anything
    // other than a valid ascii digit for a the given radix, including the first-byte
    // of multi-byte sequences
    let src = src.as_bytes();

 
    let (is_positive, digits) = match src[0] {
        b'+' => (true, &src[1..]),
        b'-' if is_signed_ty => (false, &src[1..]),
        _ => (true, src)
    };

    if digits.is_empty() {
        return Err(PIE { kind: Empty });
    }

    let mut result = T::from_u32(0);
    if is_positive {
        // The number is positive
        for &c in digits {
            let x = match (c as char).to_digit(radix) {
                Some(x) => x,
                None => return Err(PIE { kind: InvalidDigit }),
            };
            
            result = match result.checked_mul(radix) {
                Some(result) => result,
                None => return Err(PIE { kind: Overflow }),
            };
            result = match result.checked_add(x) {
                Some(result) => result,
                None => return Err(PIE { kind: Overflow }),
            };
        }
    } else {
        // The number is negative
        for &c in digits {
            let x = match (c as char).to_digit(radix) {
                Some(x) => x,
                None => return Err(PIE { kind: InvalidDigit }),
            };
            result = match result.checked_mul(radix) {
                Some(result) => result,
                None => return Err(PIE { kind: Underflow }),
            };
            result = match result.checked_sub(x) {
                Some(result) => result,
                None => return Err(PIE { kind: Underflow }),
            };
        }
    }
    Ok(result)
}


    fn test_leading_plus() {
        assert_eq!("+127".parse::<u8>().ok(), Some(127u8));
        assert_eq!("+9223372036854775807".parse::<i64>().ok(), Some(9223372036854775807i64));
    }

    fn test_invalid() {
        assert_eq!("--129".parse::<i8>().ok(), None);
        assert_eq!("++129".parse::<i8>().ok(), None);
        assert_eq!("Съешь".parse::<u8>().ok(), None);
    }

    fn test_empty() {
        assert_eq!("-".parse::<i8>().ok(), None);
        assert_eq!("+".parse::<i8>().ok(), None);
        assert_eq!("".parse::<u8>().ok(), None);
    }
