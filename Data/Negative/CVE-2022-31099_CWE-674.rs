    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(span) = self.span {
            write!(f, "{}\n  at {}", self.kind, span)
        } else {
            self.kind.fmt(f)
        }
    }
}

impl From<nom::Err<ParseError>> for ParseError {
    fn from(e: nom::Err<ParseError>) -> Self {
        match e {
            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),
            nom::Err::Error(e) | nom::Err::Failure(e) => e,
        }
    }
}

impl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {
    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {
        ParseErrorKind::Nom(kind).at(i.span())
    }

    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {
        other
    }
}

/// An error kind (without a span) than can occur only during parsing
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
#[non_exhaustive]
pub(crate) enum ParseErrorKind {
    #[error("Unknown token")]
    UnknownToken,
    #[error(transparent)]
    LexErrorWithMessage(ParseErrorMsg),
    #[error("Unexpected dot. Use `[.]` instead")]
    Dot,

    #[error("Expected {}", .0)]
    Expected(&'static str),
    #[error("There are leftover tokens that couldn't be parsed")]
    LeftoverTokens,
    #[error("Expected {}", .0)]
    ExpectedToken(Token),
    #[error("Expected code point or character")]
    ExpectedCodePointOrChar,
    #[error("The first number in a range must be smaller than the second")]
    RangeIsNotIncreasing,
    #[error("This expression can't be negated")]
    UnallowedNot,
    #[error("An expression can't be negated twice")]
    UnallowedDoubleNot,
    #[error("Range is too big, it isn't allowed to contain more than {} digits", .0)]
    RangeIsTooBig(u8),
    #[error("A variable with the same name already exists in this scope")]
    LetBindingExists,
    #[error("Unsupported escape sequence in string")]
    InvalidEscapeInStringAt(usize),
    #[error(transparent)]
    CharString(CharStringError),
    #[error(transparent)]
    CharClass(CharClassError),
    #[error(transparent)]
    CodePoint(CodePointError),
    #[error(transparent)]
    Number(#[from] NumberError),
    #[error(transparent)]
    Repetition(RepetitionError),
    #[error(transparent)]
    Unsupported(UnsupportedError),

    #[error("Recursion limit reached. Try a less nested expression")]
    RecursionLimit,

    #[error("Unknown error: {:?}", .0)]
    Nom(nom::error::ErrorKind),
    #[error("Incomplete parse")]
    Incomplete,
}

impl ParseErrorKind {
    pub(crate) fn at(self, span: Span) -> ParseError {
        ParseError { kind: self, span: Some(span) }
    }

    pub(crate) fn unknown_index(self) -> ParseError {
        ParseError { kind: self, span: None }
    }
}
    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {
        let rule = parse::parse(input, 256)?;
        rule.validate(&options)?;
        Ok(Rulex(rule))
    }

    /// Compile a `Rulex` that has been parsed, to a regex
    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {
        let mut used_names = HashMap::new();
        let mut groups_count = 0;
        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;

        let empty_span = Span::new(0, 0);

        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));
        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));
        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });
        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));

        let builtins = vec![
            ("Start", &start),
            ("End", &end),
            ("Grapheme", &grapheme),
            ("G", &grapheme),
            ("Codepoint", &codepoint),
            ("C", &codepoint),
        ];

        let mut state = CompileState {
            next_idx: 1,
            used_names,
            groups_count,
            default_quantifier: RegexQuantifier::Greedy,
            variables: builtins,
            current_vars: Default::default(),
        };
        let compiled = self.0.comp(options, &mut state)?;

        let mut buf = String::new();
        compiled.codegen(&mut buf, options.flavor);
        Ok(buf)
    }

    /// Parse a string to a `Rulex` and compile it to a regex.
    pub fn parse_and_compile(
        input: &'i str,
        parse_options: ParseOptions,
        compile_options: CompileOptions,
    ) -> Result<String, CompileError> {
        let parsed = Self::parse(input, parse_options)?;
        parsed.compile(compile_options)
    }
    pub(super) fn from(
        source: &'i str,
        tokens: &'b [(Token, Span)],
        recursion: u16,
    ) -> Result<Self, ParseError> {
        let error = tokens.iter().find_map(|&(t, span)| match t {
            Token::Error => Some((span, None)),
            Token::ErrorMsg(m) => Some((span, Some(m))),
            _ => None,
        });
        if let Some((span, msg)) = error {
            return match msg {
                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),
                None => Err(ParseErrorKind::UnknownToken.at(span)),
            };
        }

        Ok(Input { source, tokens, recursion })
    }
    fn iter_elements(&self) -> Self::IterElem {
        Input { ..*self }
    }
    pub(super) fn recursion_end(&mut self) {
        self.recursion += 1;
    }
    pub(super) fn recursion_start(&mut self) -> Result<(), ParseError> {
        self.recursion = self
            .recursion
            .checked_sub(1)
            .ok_or_else(|| ParseErrorKind::RecursionLimit.at(self.span()))?;
        Ok(())
    }
    fn take(&self, count: usize) -> Self {
        let tokens = &self.tokens[..count];

        Input { tokens, ..*self }
    }
    fn take_split(&self, count: usize) -> (Self, Self) {
        let (left, right) = self.tokens.split_at(count);

        (Input { tokens: left, ..*self }, Input { tokens: right, ..*self })
    }
pub(crate) fn parse(source: &str, recursion: u16) -> Result<Rule<'_>, ParseError> {
    let tokens = super::tokenize::tokenize(source);
    let input = Input::from(source, &tokens, recursion)?;

    let (rest, rules) = parse_modified(input)?;
    if rest.is_empty() {
        Ok(rules)
    } else {
        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))
    }
}

fn recurse<'i, 'b, O>(
    mut parser: impl Parser<Input<'i, 'b>, O, ParseError>,
) -> impl FnMut(Input<'i, 'b>) -> PResult<'i, 'b, O> {
    move |mut input| {
        input.recursion_start().map_err(nom::Err::Failure)?;

        match parser.parse(input) {
            Ok((mut input, output)) => {
                input.recursion_end();
                Ok((input, output))
            }
            Err(e) => Err(e),
        }
    }
}

pub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    enum ModifierKind {
        Enable,
        Disable,
    }

    try_map2(
        pair(
            many0(alt((
                map(
                    tuple((
                        alt((
                            map("enable", |(_, span)| (ModifierKind::Enable, span)),
                            map("disable", |(_, span)| (ModifierKind::Disable, span)),
                        )),
                        value(BooleanSetting::Lazy, "lazy"),
                        Token::Semicolon,
                    )),
                    |((kind, span_start), value, (_, span_end))| {
                        let stmt = match kind {
                            ModifierKind::Enable => Stmt::Enable(value),
                            ModifierKind::Disable => Stmt::Disable(value),
                        };
                        (stmt, span_start.join(span_end))
                    },
                ),
                map(
                    tuple((
                        "let",
                        cut(Token::Identifier),
                        cut(Token::Equals),
                        cut(recurse(parse_or)),
                        cut(Token::Semicolon),
                    )),
                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {
                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))
                    },
                ),
            ))),
            recurse(parse_or),
        ),
        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {
            if stmts.len() > 1 {
                let mut set = HashSet::new();
                for (stmt, _) in &stmts {
                    if let Stmt::Let(l) = stmt {
                        if set.contains(l.name()) {
                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));
                        }
                        set.insert(l.name());
                    }
                }
            }

            let span_end = rule.span();
            for (stmt, span) in stmts.into_iter().rev() {
                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));
            }
            Ok(rule)
        },
        nom::Err::Failure,
    )(input)
}
pub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        try_map(
            pair(Token::Not, opt(recurse(parse_fixes))),
            |(_, rule)| {
                if let Some(mut rule) = rule {
                    rule.negate()?;
                    Ok(rule)
                } else {
                    Err(ParseErrorKind::Expected("expression"))
                }
            },
            nom::Err::Failure,
        ),
        map(pair(parse_lookaround, recurse(parse_modified)), |((kind, span), rule)| {
            let span = span.join(rule.span());
            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))
        }),
        try_map2(
            pair(parse_atom, many0(parse_repetition)),
            |(mut rule, repetitions)| {
                let mut prev_syntax = RepSyntax::ExplicitQuantifier;
                for (kind, quantifier, span, syntax) in repetitions {
                    if matches!(
                        (&prev_syntax, &syntax),
                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)
                    ) {
                        return Err(ParseErrorKind::Repetition(
                            RepetitionError::QuestionMarkAfterRepetition,
                        )
                        .at(span));
                    }
                    prev_syntax = syntax;

                    let span = rule.span().join(span);
                    rule =
                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));
                }
                Ok(rule)
            },
            nom::Err::Failure,
        ),
    ))(input)
}

pub(super) fn parse_lookaround<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (LookaroundKind, Span)> {
    alt((
        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),
        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),
    ))(input)
}

pub(super) enum RepSyntax {
    ExplicitQuantifier,
    QuestionMark,
    Other,
}

pub(super) fn parse_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {
    map(
        pair(
            alt((
                map(Token::QuestionMark, |(_, span)| {
                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)
                }),
                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),
                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),
                parse_braced_repetition,
            )),
            map(
                opt(alt((
                    map("greedy", |(_, span)| (Quantifier::Greedy, span)),
                    map("lazy", |(_, span)| (Quantifier::Lazy, span)),
                ))),
                |a| match a {
                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),
                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),
                },
            ),
        ),
        |((kind, span1, rs1), (quantifier, span2, rs2))| {
            (
                kind,
                quantifier,
                span1.join(span2),
                match (rs1, rs2) {
                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,
                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,
                    _ => RepSyntax::Other,
                },
            )
        },
    )(input)
}

pub(super) fn parse_braced_repetition<'i, 'b>(
    input: Input<'i, 'b>,
) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {
    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {
        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)
    }

    map(
        tuple((
            Token::OpenBrace,
            cut(alt((
                try_map(
                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),
                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),
                    nom::Err::Failure,
                ),
                map(parse_u32, RepetitionKind::fixed),
            ))),
            cut(Token::CloseBrace),
        )),
        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),
    )(input)
}

pub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {
    alt((
        parse_group,
        parse_string,
        parse_char_class,
        parse_boundary,
        parse_reference,
        map(parse_code_point, |(c, span)| {
            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))
        }),
        parse_range,
        parse_variable,
        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),
        err(|| ParseErrorKind::Expected("expression")),
    ))(input)
}