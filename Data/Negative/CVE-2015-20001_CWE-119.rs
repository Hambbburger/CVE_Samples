// hole), shift along the others and move the removed element back into the
    // vector at the final location of the hole.
    // The `Hole` type is used to represent this, and make sure
    // the hole is filled back at the end of its scope, even on panic.
    // Using a hole reduces the constant factor compared to using swaps,
    // which involves twice as many moves.
    fn sift_up(&mut self, start: usize, pos: usize) {
        unsafe {
            // Take out the value at `pos` and create a hole.
            let mut hole = Hole::new(&mut self.data, pos);

           
            while hole.pos() > start {
                let parent = (hole.pos() - 1) / 2;
                if hole.removed() <= hole.get(parent) { break }
                hole.move_to(parent);
            }
        }
    }

fn sift_down_range(&mut self, mut pos: usize, end: usize) {
        let start = pos;
        unsafe {
           
            let mut hole = Hole::new(&mut self.data, pos);
            let mut child = 2 * pos + 1;
            while child < end {
                let right = child + 1;
                if right < end && !(hole.get(child) > hole.get(right)) {
                    child = right;
                }
               
                hole.move_to(child);
                child = 2 * hole.pos() + 1;
            }

            
            pos = hole.pos;
        }
        self.sift_up(start, pos);
    }
