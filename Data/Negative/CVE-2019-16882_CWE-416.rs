/// The given index is a "backwards" index.
    fn resolve_index_to_str(&self, index: usize) -> Option<&str> {
        let len_bytes = self.buffer.get(index - LEN_LOOKBEHIND..index)?;
        let len_bytes = <&[u8; LEN_LOOKBEHIND]>::try_from(len_bytes).unwrap();
        let len = decode_len_backwards(len_bytes);
        let str_bytes = self.buffer.get(index..index + len)?;
        // SAFETY: It is guaranteed by the backend that only valid strings
        //         are stored in this portion of the buffer.
        let string = unsafe { str::from_utf8_unchecked(str_bytes) };
        Some(string)
    }



unsafe fn resolve_index_to_str_unchecked(&self, index: usize) -> &str {
        // SAFETY: The function is marked unsafe so that the caller guarantees
        //         that required invariants are checked.
        let len_bytes =
            unsafe { self.buffer.get_unchecked(index - LEN_LOOKBEHIND..index) };
        let len_bytes = <&[u8; LEN_LOOKBEHIND]>::try_from(len_bytes).unwrap();
        let len = decode_len_backwards(len_bytes);
        let str_bytes = unsafe { self.buffer.get_unchecked(index..index + len) };
// SAFETY: It is guaranteed by the backend that only valid strings
        //         are stored in this portion of the buffer.
        unsafe { str::from_utf8_unchecked(str_bytes) }
    }


fn push_string(&mut self, string: &str) -> S {
        if self.buffer.is_empty() {
            // Ensure at least LONG_LEN bytes are present in the buffer, so that LEN_LOOKBEHIND works.
            self.buffer.resize(LONG_LEN, 0);
        }
        if string.len() <= MAX_SHORT_LEN {
            self.buffer.reserve(SHORT_LEN + string.len());
            self.buffer.push(string.len() as u8);
        } else {
            self.buffer
                .reserve(SHORT_LEN + LONG_LEN + SHORT_LEN + string.len());
            self.buffer.push(SENTINEL_SHORT_LEN);
            self.buffer.extend_from_slice(&string.len().to_ne_bytes());
            self.buffer.push(SENTINEL_SHORT_LEN);
        }
        let symbol = expect_valid_symbol(self.buffer.len());
        self.buffer.extend_from_slice(string.as_bytes());
        self.len_strings += 1;
        symbol
    }

fn with_capacity(capacity: usize) -> Self {
        /// According to google the approx. word length is 5.
        const DEFAULT_STR_LEN: usize = 5;
        let bytes_per_string = DEFAULT_STR_LEN + SHORT_LEN;
        Self {
            len_strings: 0,
            buffer: Vec::with_capacity(capacity * bytes_per_string),
            marker: Default::default(),
        }
    }

fn resolve(&self, symbol: Self::Symbol) -> Option<&str> {
        self.resolve_index_to_str(symbol.to_usize())
    }

pub fn new(backend: &'a BufferBackend<S>) -> Self {
        Self {
            backend,
            yielded: 0,
            current: LONG_LEN,
        }
    }

fn next(&mut self) -> Option<Self::Item> {
        
        if self.backend.len_strings == self.yielded {
            return None
        }
        // Parse length forwards, not backwards. To avoid the need for padding at the *end* of the buffer,
        // when decoding forwards we use branchy code, not branchless.
        let i = self.current;
        // SAFETY: index is guaranteed valid because the iterator controls it.
        let short_len = unsafe { *self.backend.buffer.get_unchecked(i) };
        let (len, len_len) = if short_len == SENTINEL_SHORT_LEN {
            // Long-string decoding.
            self.current += 1;
            // SAFETY: index is guaranteed valid because the iterator controls it.
            let len_bytes = unsafe {
                self.backend
                    .buffer
                    .get_unchecked(i + SHORT_LEN..i + SHORT_LEN + LONG_LEN)
            };
            let len = usize::from_ne_bytes(<[u8; LONG_LEN]>::try_from(len_bytes).unwrap())
                as usize;
            (len, SHORT_LEN + LONG_LEN + SHORT_LEN)
        } else {
            (short_len as usize, SHORT_LEN)
        };
        // SAFETY: index is guaranteed valid because the iterator controls it.
        let str_bytes = unsafe {
            self.backend
                .buffer
                .get_unchecked(i + len_len..i + len_len + len)
        };
        // SAFETY: payload guaranteed valid utf8, because that's how it was written to the buffer.
        let str = unsafe { str::from_utf8_unchecked(str_bytes) };
        self.current += len_len + len;
        self.yielded += 1;
        Some((expect_valid_symbol(i + len_len), str))
    }
