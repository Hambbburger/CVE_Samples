pub fn is_permitted_char(c: char) -> bool {
    is_permitted_printable_char(c) || is_permitted_newline_char(c)
}
pub fn is_permitted_newline_char(c: char) -> bool {
    let x = c as u32;
    x == 0x0A
}
pub fn is_permitted_printable_char(c: char) -> bool {
    let x = c as u32;
    let is_above_space = x >= 0x20; // Don't allow meta characters
    let is_below_tilde = x <= 0x7E; // Don't allow DEL meta character
    let is_tab = x == 0x09; // Allow tabs
    (is_above_space && is_below_tilde) || is_tab
}
pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {
    let stripped_string = &strip_comments_and_verify(cmd_str)?;
    let parser = syntax::CmdParser::new();
    match parser.parse(stripped_string) {
        Ok(cmd) => Ok(cmd),
        Err(e) => handle_error(e, stripped_string),
    }
}
pub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {
    let stripped_string = &strip_comments_and_verify(modules_str)?;
    let parser = syntax::ModuleParser::new();
    match parser.parse(stripped_string) {
        Ok(module) => Ok(module),
        Err(e) => handle_error(e, stripped_string),
    }
}
pub fn parse_program(program_str: &str) -> Result<ast::Program> {
    let stripped_string = &strip_comments_and_verify(program_str)?;
    let parser = syntax::ProgramParser::new();
    match parser.parse(stripped_string) {
        Ok(program) => Ok(program),
        Err(e) => handle_error(e, stripped_string),
    }
}
pub fn parse_script(script_str: &str) -> Result<ast::Script> {
    let stripped_string = &strip_comments_and_verify(script_str)?;
    let parser = syntax::ScriptParser::new();
    match parser.parse(stripped_string) {
        Ok(script) => Ok(script),
        Err(e) => handle_error(e, stripped_string),
    }
}
fn strip_comments(source: &str) -> String {
    const SLASH: char = '/';
    const SPACE: char = ' ';

    let mut in_comment = false;
    let mut acc = String::with_capacity(source.len());
    let mut char_iter = source.chars().peekable();

    while let Some(chr) = char_iter.next() {
        let at_newline = is_permitted_newline_char(chr);
        let at_or_after_slash_slash =
            in_comment || (chr == SLASH && char_iter.peek().map(|c| *c == SLASH).unwrap_or(false));
        in_comment = !at_newline && at_or_after_slash_slash;
        acc.push(if in_comment { SPACE } else { chr });
    }

    acc
}
fn strip_comments_and_verify(string: &str) -> Result<String> {
    verify_string(string)?;
    Ok(strip_comments(string))
}
fn verify_string(string: &str) -> Result<()> {
    match string.chars().find(|c| !is_permitted_char(*c)) {
        None => Ok(()),
        Some(chr) => bail!(
            "Parser Error: invalid character {} found when reading file.\
             Only ascii printable, tabs (\\t), and \\n line ending characters are permitted.",
            chr
        ),
    }
}