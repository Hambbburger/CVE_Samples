	fn domain(&self, token: &str) -> Option<Origin>;
}

impl<F> WebProxyTokens for F where F: Fn(String) -> Option<Origin> + Send + Sync {
	fn domain(&self, token: &str) -> Option<Origin> { self(token.to_owned()) }
}
fn should_correctly_handle_long_label_when_splitted() {
	// given
	let (server, fetch) = serve_with_fetch("xolrg9fePeQyKLnL", "https://contribution.melonport.com");

	// when
	let response = request(server,
		"\
			GET /styles.css?test=123 HTTP/1.1\r\n\
			Host: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://contribution.melonport.com/styles.css?test=123");
	fetch.assert_no_more_requests();
}
fn should_disallow_non_get_requests() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			POST / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Content-Type: application/json\r\n\
			Connection: close\r\n\
			\r\n\
			123\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 405 Method Not Allowed");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_fix_absolute_requests_based_on_referer() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET /styles.css HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			Referer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 302 Found");
	response.assert_header("Location", "/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css");

	fetch.assert_no_more_requests();
}
fn should_fix_absolute_requests_based_on_referer_in_url() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET /styles.css HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			Referer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 302 Found");
	response.assert_header("Location", "/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css");

	fetch.assert_no_more_requests();
}
fn should_return_error_on_invalid_protocol() {
	// given
	let (server, fetch) = serve_with_fetch("token", "ftp://parity.io");

	// when
	let response = request(server,
		"\
			GET /web/token/ftp/parity.io/ HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 400 Bad Request");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_return_error_on_invalid_token() {
	// given
	let (server, fetch) = serve_with_fetch("test", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 400 Bad Request");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_return_error_on_non_whitelisted_domain() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://ethcore.io");

	// when
	let response = request(server,
		"\
			GET / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 400 Bad Request");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_no_more_requests();
}
fn should_stream_web_content() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET / HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/");
	fetch.assert_no_more_requests();
}
fn should_support_base32_encoded_web_urls() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET /styles.css?test=123 HTTP/1.1\r\n\
			Host: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/styles.css?test=123");
	fetch.assert_no_more_requests();
}
fn should_support_base32_encoded_web_urls_as_path() {
	// given
	let (server, fetch) = serve_with_fetch("token", "https://parity.io");

	// when
	let response = request(server,
		"\
			GET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\r\n\
			Host: localhost:8080\r\n\
			Connection: close\r\n\
			\r\n\
		"
	);

	// then
	response.assert_status("HTTP/1.1 200 OK");
	assert_security_headers_for_embed(&response.headers);

	fetch.assert_requested("https://parity.io/styles.css?test=123");
	fetch.assert_no_more_requests();
}
	pub fn new<P: AsRef<Path>>(dapps_path: P, registrar: Arc<ContractClient>, remote: Remote) -> Self {
		ServerBuilder {
			dapps_path: dapps_path.as_ref().to_owned(),
			registrar: registrar,
			sync_status: Arc::new(|| false),
			web_proxy_tokens: Arc::new(|_| None),
			signer_address: None,
			allowed_hosts: DomainsValidation::Disabled,
			remote: remote,
			fetch: None,
		}
	}
pub fn serve_with_fetch(web_token: &'static str, domain: &'static str) -> (Server, FakeFetch) {
	let fetch = FakeFetch::default();
	let f = fetch.clone();
	let (server, _) = init_server(move |builder| {
		builder
			.fetch(f.clone())
			.web_proxy_tokens(Arc::new(move |token| {
				if &token == web_token { Some(domain.into()) } else { None }
			}))
	}, Default::default(), Remote::new_sync());

	(server, fetch)
}
	fn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {
		let token_and_url = self.path.app_params.get(0)
			.map(|encoded| encoded.replace('.', ""))
			.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))
			.and_then(|data| String::from_utf8(data).ok())
			.ok_or_else(|| State::Error(ContentHandler::error(
				StatusCode::BadRequest,
				"Invalid parameter",
				"Couldn't parse given parameter:",
				self.path.app_params.get(0).map(String::as_str),
				self.embeddable_on.clone()
			)))?;

		let mut token_it = token_and_url.split('+');
		let token = token_it.next();
		let target_url = token_it.next();

		// Check if token supplied in URL is correct.
		let domain = match token.and_then(|token| self.web_proxy_tokens.domain(token)) {
			Some(domain) => domain,
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid Access Token", "Invalid or old web proxy access token supplied.", Some("Try refreshing the page."), self.embeddable_on.clone()
				)));
			}
		};

		// Validate protocol
		let mut target_url = match target_url {
			Some(url) if url.starts_with("http://") || url.starts_with("https://") => url.to_owned(),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid Protocol", "Invalid protocol used.", None, self.embeddable_on.clone()
				)));
			}
		};

		if !target_url.starts_with(&*domain) {
			return Err(State::Error(ContentHandler::error(
				StatusCode::BadRequest, "Invalid Domain", "Dapp attempted to access invalid domain.", Some(&target_url), self.embeddable_on.clone(),
			)));
		}

		if !target_url.ends_with("/") {
			target_url = format!("{}/", target_url);
		}

		// TODO [ToDr] Should just use `path.app_params`
		let (path, query) = match (&url, self.path.using_dapps_domains) {
			(&Some(ref url), true) => (&url.path[..], &url.query),
			(&Some(ref url), false) => (&url.path[2..], &url.query),
			_ => {
				return Err(State::Error(ContentHandler::error(
					StatusCode::BadRequest, "Invalid URL", "Couldn't parse URL", None, self.embeddable_on.clone()
				)));
			}
		};

		let query = match *query {
			Some(ref query) => format!("?{}", query),
			None => "".into(),
		};

		Ok(format!("{}{}{}", target_url, path.join("/"), query))
	}
	pub fn dapps_middleware(
		deps: Dependencies,
		dapps_path: PathBuf,
		extra_dapps: Vec<PathBuf>,
		dapps_domain: String,
	) -> Result<Middleware, String> {
		let signer = deps.signer;
		let parity_remote = parity_reactor::Remote::new(deps.remote.clone());
		let web_proxy_tokens = Arc::new(move |token| signer.web_proxy_access_token_domain(&token));

		Ok(parity_dapps::Middleware::dapps(
			parity_remote,
			deps.ui_address,
			dapps_path,
			extra_dapps,
			dapps_domain,
			deps.contract_client,
			deps.sync_status,
			web_proxy_tokens,
			deps.fetch,
		))
	}
	pub fn generate_web_proxy_access_token(&self, domain: Origin) -> String {
		let token = random_string(16);
		let mut tokens = self.web_proxy_tokens.lock();
		tokens.prune();
		tokens.insert(token.clone(), domain);
		token
	}
	pub fn web_proxy_access_token_domain(&self, token: &String) -> Option<Origin> {
		self.web_proxy_tokens.lock().get(token).cloned()
	}
	fn generate_web_proxy_token(&self, domain: String) -> Result<String, Error> {
		Ok(self.signer.generate_web_proxy_access_token(domain.into()))
	}