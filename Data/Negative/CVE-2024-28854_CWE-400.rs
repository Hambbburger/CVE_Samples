async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3000).into();
    let counter = Arc::new(AtomicU64::new(0));

    let mut listener = tls_listener::builder(tls_acceptor())
        .accept_batch_size(NonZeroUsize::new(10).unwrap())
        .listen(TcpListener::bind(addr).await.expect("Failed to bind port"));

    let (tx, mut rx) = mpsc::channel::<Acceptor>(1);
    let http = http1::Builder::new();
    loop {
        tokio::select! {
            conn = listener.accept() => {
                match conn {
                    Ok((conn, remote_addr)) => {
                        let http = http.clone();
                        let tx = tx.clone();
                        let counter = counter.clone();
                        tokio::spawn(async move {
                            let svc = service_fn(move |request| handle_request(tx.clone(), counter.clone(), request));
                            if let Err(err) = http.serve_connection(TokioIo::new(conn), svc).await {
                                eprintln!("Application error (client address: {remote_addr}): {err}");
                            }
                        });
                    },
                    Err(e) => {
                        if let Some(remote_addr) = e.peer_addr() {
                            eprint!("[client {remote_addr}] ");
                        }
                        eprintln!("Bad connection: {}", e);
                    }
                }
            },
            message = rx.recv() => {
                // Certificate is loaded on another task; we don't want to block the listener loop
                let acceptor = message.expect("Channel should not be closed");
                println!("Rotating certificate...");
                listener.replace_acceptor(acceptor);
            }
        }
    }
}

pub fn poll_accept(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<<Self as Stream>::Item> {
        let mut this = self.project();

        loop {
            let mut empty_listener = false;
            for _ in 0..this.accept_batch_size.get() {
                match this.listener.as_mut().poll_accept(cx) {
                    Poll::Pending => {
                        empty_listener = true;
                        break;
                    }
                    Poll::Ready(Ok((conn, addr))) => {
                        this.waiting.push(Waiting {
                            inner: timeout(*this.timeout, this.tls.accept(conn)),
                            peer_addr: Some(addr),
                        });
                    }
                    Poll::Ready(Err(e)) => {
                        return Poll::Ready(Err(Error::ListenerError(e)));
                    }
                }
            }

            match this.waiting.poll_next_unpin(cx) {
                Poll::Ready(Some(result)) => return Poll::Ready(result),
                // If we don't have anything waiting yet,
                // then we are still pending,
                Poll::Ready(None) | Poll::Pending => {
                    if empty_listener {
                        return Poll::Pending;
                    }
                }
            }
        }
    }

    /// Defaults to `DEFAULT_ACCEPT_BATCH_SIZE`.
    pub fn accept_batch_size(&mut self, size: NonZeroUsize) -> &mut Self {
        self.accept_batch_size = size;
        self
    }

pub fn listen<A: AsyncAccept>(&self, listener: A) -> TlsListener<A, T>
    where
        T: AsyncTls<A::Connection>,
    {
        TlsListener {
            listener,
            tls: self.tls.clone(),
            waiting: FuturesUnordered::new(),
            accept_batch_size: self.accept_batch_size,
            timeout: self.handshake_timeout,
        }
    }

pub fn builder<T>(tls: T) -> Builder<T> {
    Builder {
        tls,
        accept_batch_size: DEFAULT_ACCEPT_BATCH_SIZE,
        handshake_timeout: DEFAULT_HANDSHAKE_TIMEOUT,
    }
}
