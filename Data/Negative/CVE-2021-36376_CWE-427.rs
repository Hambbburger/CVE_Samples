pub fn retrieve_less_version() -> Option<usize> {
    if let Ok(less_path) = grep_cli::resolve_binary("less") {
        let cmd = Command::new(less_path).arg("--version").output().ok()?;
        parse_less_version(&cmd.stdout)
    } else {
        None
    }
}
fn _make_process_from_less_path(
    less_path: PathBuf,
    args: &[String],
    replace_arguments_to_less: bool,
    quit_if_one_screen: bool,
    config: &config::Config,
) -> Option<Command> {
    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {
        let mut p = Command::new(&less_path);
        if args.is_empty() || replace_arguments_to_less {
            p.args(vec!["--RAW-CONTROL-CHARS"]);

            // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older
            // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.
            //
            // See: http://www.greenwoodsoftware.com/less/news.530.html
            //
            // For newer versions (530 or 558 on Windows), we omit '--no-init' as it
            // is not needed anymore.
            match retrieve_less_version() {
                None => {
                    p.arg("--no-init");
                }
                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {
                    p.arg("--no-init");
                }
                _ => {}
            }

            if quit_if_one_screen {
                p.arg("--quit-if-one-screen");
            }
        } else {
            p.args(args);
        }
        p.env("LESSCHARSET", "UTF-8");
        p.env("LESSANSIENDCHARS", "mK");
        if config.navigate {
            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)
            {
                p.env("LESSHISTFILE", hist_file);
                if config.show_themes {
                    p.arg("+n");
                }
            }
        }
        Some(p)
    } else {
        None
    }
}
fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {
    if pager_path.file_stem() == Some(&OsString::from("delta")) {
        eprintln!(
            "\
It looks like you have set delta as the value of $PAGER. \
This would result in a non-terminating recursion. \
delta is not an appropriate value for $PAGER \
(but it is an appropriate value for $GIT_PAGER)."
        );
        std::process::exit(1);
    }
    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {
        let mut p = Command::new(&pager_path);
        p.args(args);
        Some(p)
    } else {
        None
    }
}
    fn try_pager(
        quit_if_one_screen: bool,
        pager_from_config: Option<String>,
        config: &config::Config,
    ) -> Result<Self> {
        let mut replace_arguments_to_less = false;

        let pager_from_env = match (
            env::var("DELTA_PAGER"),
            env::var("BAT_PAGER"),
            env::var("PAGER"),
        ) {
            (Ok(delta_pager), _, _) => Some(delta_pager),
            (_, Ok(bat_pager), _) => Some(bat_pager),
            (_, _, Ok(pager)) => {
                // less needs to be called with the '-R' option in order to properly interpret ANSI
                // color sequences. If someone has set PAGER="less -F", we therefore need to
                // overwrite the arguments and add '-R'.
                // We only do this for PAGER, since it is used in other contexts.
                replace_arguments_to_less = true;
                Some(pager)
            }
            _ => None,
        };

        if pager_from_config.is_some() {
            replace_arguments_to_less = false;
        }

        let pager = pager_from_config
            .or(pager_from_env)
            .unwrap_or_else(|| String::from("less"));

        let pagerflags =
            shell_words::split(&pager).chain_err(|| "Could not parse pager command.")?;

        Ok(match pagerflags.split_first() {
            Some((pager_name, args)) => {
                let pager_path = PathBuf::from(pager_name);

                let is_less = pager_path.file_stem() == Some(&OsString::from("less"));

                let process = if is_less {
                    _make_process_from_less_path(
                        pager_path,
                        args,
                        replace_arguments_to_less,
                        quit_if_one_screen,
                        config,
                    )
                } else {
                    _make_process_from_pager_path(pager_path, args)
                };
                if let Some(mut process) = process {
                    process
                        .stdin(Stdio::piped())
                        .spawn()
                        .map(OutputType::Pager)
                        .unwrap_or_else(|_| OutputType::stdout())
                } else {
                    OutputType::stdout()
                }
            }
            None => OutputType::stdout(),
        })
    }
fn diff(
    minus_file: Option<&PathBuf>,
    plus_file: Option<&PathBuf>,
    config: &config::Config,
    writer: &mut dyn Write,
) -> i32 {
    use std::io::BufReader;
    let die = || {
        eprintln!(
            "\
The main way to use delta is to configure it as the pager for git: \
see https://github.com/dandavison/delta#configuration. \
You can also use delta to diff two files: `delta file_A file_B`."
        );
        process::exit(config.error_exit_code);
    };
    let diff_command = "git";
    let minus_file = minus_file.unwrap_or_else(die);
    let plus_file = plus_file.unwrap_or_else(die);
    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {
        Ok(path) => path,
        Err(_) => return config.error_exit_code,
    };
    let mut diff_process = process::Command::new(diff_command_path)
        .args(&["diff", "--no-index"])
        .args(&[minus_file, plus_file])
        .stdout(process::Stdio::piped())
        .spawn()
        .unwrap_or_else(|err| {
            eprintln!("Failed to execute the command '{}': {}", diff_command, err);
            process::exit(config.error_exit_code);
        });

    let exit_code = diff_process
        .wait()
        .unwrap_or_else(|_| {
            delta_unreachable(&format!("'{}' process not running.", diff_command));
        })
        .code()
        .unwrap_or_else(|| {
            eprintln!("'{}' process terminated without exit status.", diff_command);
            process::exit(config.error_exit_code);
        });

    if let Err(error) = delta(
        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),
        writer,
        &config,
    ) {
        match error.kind() {
            ErrorKind::BrokenPipe => process::exit(0),
            _ => {
                eprintln!("{}", error);
                process::exit(config.error_exit_code);
            }
        }
    };
    exit_code
}